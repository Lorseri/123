// Code generated from java-escape by ANTLR 4.11.1. DO NOT EDIT.

package parser // MySqlParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type MySqlParser struct {
	*antlr.BaseParser
}

var mysqlparserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func mysqlparserParserInit() {
	staticData := &mysqlparserParserStaticData
	staticData.literalNames = []string{
		"", "", "", "", "", "'ADD'", "'ALL'", "'ALTER'", "'ALWAYS'", "'ANALYZE'",
		"'AND'", "'ARRAY'", "'AS'", "'ASC'", "'ATTRIBUTE'", "'BEFORE'", "'BETWEEN'",
		"'BOTH'", "'BUCKETS'", "'BY'", "'CALL'", "'CASCADE'", "'CASE'", "'CAST'",
		"'CHANGE'", "'CHARACTER'", "'CHECK'", "'COLLATE'", "'COLUMN'", "'CONDITION'",
		"'CONSTRAINT'", "'CONTINUE'", "'CONVERT'", "'CREATE'", "'CROSS'", "'CURRENT'",
		"'CURRENT_ROLE'", "'CURRENT_USER'", "'CURSOR'", "'DATABASE'", "'DATABASES'",
		"'DECLARE'", "'DEFAULT'", "'DELAYED'", "'DELETE'", "'DESC'", "'DESCRIBE'",
		"'DETERMINISTIC'", "'DIAGNOSTICS'", "'DISTINCT'", "'DISTINCTROW'", "'DROP'",
		"'EACH'", "'ELSE'", "'ELSEIF'", "'EMPTY'", "'ENCLOSED'", "'ESCAPED'",
		"'EXCEPT'", "'EXISTS'", "'EXIT'", "'EXPLAIN'", "'FALSE'", "'FETCH'",
		"'FOR'", "'FORCE'", "'FOREIGN'", "'FROM'", "'FULLTEXT'", "'GENERATED'",
		"'GET'", "'GRANT'", "'GROUP'", "'HAVING'", "'HIGH_PRIORITY'", "'HISTOGRAM'",
		"'IF'", "'IGNORE'", "'IGNORED'", "'IN'", "'INDEX'", "'INFILE'", "'INNER'",
		"'INOUT'", "'INSERT'", "'INTERVAL'", "'INTO'", "'IS'", "'ITERATE'",
		"'JOIN'", "'KEY'", "'KEYS'", "'KILL'", "'LATERAL'", "'LEADING'", "'LEAVE'",
		"'LEFT'", "'LIKE'", "'LIMIT'", "'LINEAR'", "'LINES'", "'LOAD'", "'LOCK'",
		"'LOCKED'", "'LOOP'", "'LOW_PRIORITY'", "'MASTER_BIND'", "'MASTER_SSL_VERIFY_SERVER_CERT'",
		"'MATCH'", "'MAXVALUE'", "'MINVALUE'", "'MODIFIES'", "'NATURAL'", "'NOT'",
		"'NO_WRITE_TO_BINLOG'", "'NULL'", "'NUMBER'", "'ON'", "'OPTIMIZE'",
		"'OPTION'", "'OPTIONAL'", "'OPTIONALLY'", "'OR'", "'ORDER'", "'OUT'",
		"'OUTER'", "'OUTFILE'", "'OVER'", "'PARTITION'", "'PRIMARY'", "'PROCEDURE'",
		"'PURGE'", "'RANGE'", "'READ'", "'READS'", "'REFERENCES'", "'REGEXP'",
		"'RELEASE'", "'RENAME'", "'REPEAT'", "'REPLACE'", "'REQUIRE'", "'RESIGNAL'",
		"'RESTRICT'", "'RETAIN'", "'RETURN'", "'REVOKE'", "'RIGHT'", "'RLIKE'",
		"'SCHEMA'", "'SCHEMAS'", "'SELECT'", "'SET'", "'SEPARATOR'", "'SHOW'",
		"'SIGNAL'", "'SKIP'", "'SPATIAL'", "'SQL'", "'SQLEXCEPTION'", "'SQLSTATE'",
		"'SQLWARNING'", "'SQL_BIG_RESULT'", "'SQL_CALC_FOUND_ROWS'", "'SQL_SMALL_RESULT'",
		"'SSL'", "'STACKED'", "'STARTING'", "'STATEMENT'", "'STRAIGHT_JOIN'",
		"'TABLE'", "'TERMINATED'", "'THEN'", "'TO'", "'TRAILING'", "'TRIGGER'",
		"'TRUE'", "'UNDO'", "'UNION'", "'UNIQUE'", "'UNLOCK'", "'UNSIGNED'",
		"'UPDATE'", "'USAGE'", "'USE'", "'USING'", "'VALUES'", "'WHEN'", "'WHERE'",
		"'WHILE'", "'WITH'", "'WRITE'", "'XOR'", "'ZEROFILL'", "'ANNS'", "'L2'",
		"'IP'", "'TINYINT'", "'SMALLINT'", "'MEDIUMINT'", "'MIDDLEINT'", "'INT'",
		"'INT1'", "'INT2'", "'INT3'", "'INT4'", "'INT8'", "'INTEGER'", "'BIGINT'",
		"'REAL'", "'DOUBLE'", "'PRECISION'", "'FLOAT'", "'FLOAT4'", "'FLOAT8'",
		"'DECIMAL'", "'DEC'", "'NUMERIC'", "'DATE'", "'TIME'", "'TIMESTAMP'",
		"'DATETIME'", "'YEAR'", "'CHAR'", "'VARCHAR'", "'NVARCHAR'", "'NATIONAL'",
		"'BINARY'", "'VARBINARY'", "'TINYBLOB'", "'BLOB'", "'MEDIUMBLOB'", "'LONG'",
		"'LONGBLOB'", "'TINYTEXT'", "'TEXT'", "'MEDIUMTEXT'", "'LONGTEXT'",
		"'ENUM'", "'VARYING'", "'SERIAL'", "'YEAR_MONTH'", "'DAY_HOUR'", "'DAY_MINUTE'",
		"'DAY_SECOND'", "'HOUR_MINUTE'", "'HOUR_SECOND'", "'MINUTE_SECOND'",
		"'SECOND_MICROSECOND'", "'MINUTE_MICROSECOND'", "'HOUR_MICROSECOND'",
		"'DAY_MICROSECOND'", "'JSON_ARRAY'", "'JSON_ARRAYAGG'", "'JSON_ARRAY_APPEND'",
		"'JSON_ARRAY_INSERT'", "'JSON_CONTAINS'", "'JSON_CONTAINS_PATH'", "'JSON_DEPTH'",
		"'JSON_EXTRACT'", "'JSON_INSERT'", "'JSON_KEYS'", "'JSON_LENGTH'", "'JSON_MERGE'",
		"'JSON_MERGE_PATCH'", "'JSON_MERGE_PRESERVE'", "'JSON_OBJECT'", "'JSON_OBJECTAGG'",
		"'JSON_OVERLAPS'", "'JSON_PRETTY'", "'JSON_QUOTE'", "'JSON_REMOVE'",
		"'JSON_REPLACE'", "'JSON_SCHEMA_VALID'", "'JSON_SCHEMA_VALIDATION_REPORT'",
		"'JSON_SEARCH'", "'JSON_SET'", "'JSON_STORAGE_FREE'", "'JSON_STORAGE_SIZE'",
		"'JSON_TABLE'", "'JSON_TYPE'", "'JSON_UNQUOTE'", "'JSON_VALID'", "'JSON_VALUE'",
		"'NESTED'", "'ORDINALITY'", "'PATH'", "'AVG'", "'BIT_AND'", "'BIT_OR'",
		"'BIT_XOR'", "'COUNT'", "'CUME_DIST'", "'DENSE_RANK'", "'FIRST_VALUE'",
		"'GROUP_CONCAT'", "'LAG'", "'LAST_VALUE'", "'LEAD'", "'MAX'", "'MIN'",
		"'NTILE'", "'NTH_VALUE'", "'PERCENT_RANK'", "'RANK'", "'ROW_NUMBER'",
		"'STD'", "'STDDEV'", "'STDDEV_POP'", "'STDDEV_SAMP'", "'SUM'", "'VAR_POP'",
		"'VAR_SAMP'", "'VARIANCE'", "'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'",
		"'LOCALTIME'", "'CURDATE'", "'CURTIME'", "'DATE_ADD'", "'DATE_SUB'",
		"'EXTRACT'", "'LOCALTIMESTAMP'", "'NOW'", "'POSITION'", "'SUBSTR'",
		"'SUBSTRING'", "'SYSDATE'", "'TRIM'", "'UTC_DATE'", "'UTC_TIME'", "'UTC_TIMESTAMP'",
		"'ACCOUNT'", "'ACTION'", "'AFTER'", "'AGGREGATE'", "'ALGORITHM'", "'ANY'",
		"'AT'", "'AUTHORS'", "'AUTOCOMMIT'", "'AUTOEXTEND_SIZE'", "'AUTO_INCREMENT'",
		"'AVG_ROW_LENGTH'", "'BEGIN'", "'BINLOG'", "'BIT'", "'BLOCK'", "'BOOL'",
		"'BOOLEAN'", "'BTREE'", "'CACHE'", "'CASCADED'", "'CHAIN'", "'CHANGED'",
		"'CHANNEL'", "'CHECKSUM'", "'PAGE_CHECKSUM'", "'CIPHER'", "'CLASS_ORIGIN'",
		"'CLIENT'", "'CLOSE'", "'CLUSTERING'", "'COALESCE'", "'CODE'", "'COLUMNS'",
		"'COLUMN_FORMAT'", "'COLUMN_NAME'", "'COMMENT'", "'COMMIT'", "'COMPACT'",
		"'COMPLETION'", "'COMPRESSED'", "", "'CONCURRENT'", "'CONNECT'", "'CONNECTION'",
		"'CONSISTENT'", "'CONSTRAINT_CATALOG'", "'CONSTRAINT_SCHEMA'", "'CONSTRAINT_NAME'",
		"'CONTAINS'", "'CONTEXT'", "'CONTRIBUTORS'", "'COPY'", "'CPU'", "'CYCLE'",
		"'CURSOR_NAME'", "'DATA'", "'DATAFILE'", "'DEALLOCATE'", "'DEFAULT_AUTH'",
		"'DEFINER'", "'DELAY_KEY_WRITE'", "'DES_KEY_FILE'", "'DIRECTORY'", "'DISABLE'",
		"'DISCARD'", "'DISK'", "'DO'", "'DUMPFILE'", "'DUPLICATE'", "'DYNAMIC'",
		"'ENABLE'", "'ENCRYPTED'", "'ENCRYPTION'", "'ENCRYPTION_KEY_ID'", "'END'",
		"'ENDS'", "'ENGINE'", "'ENGINES'", "'ERROR'", "'ERRORS'", "'ESCAPE'",
		"'EVEN'", "'EVENT'", "'EVENTS'", "'EVERY'", "'EXCHANGE'", "'EXCLUSIVE'",
		"'EXPIRE'", "'EXPORT'", "'EXTENDED'", "'EXTENT_SIZE'", "'FAILED_LOGIN_ATTEMPTS'",
		"'FAST'", "'FAULTS'", "'FIELDS'", "'FILE_BLOCK_SIZE'", "'FILTER'", "'FIRST'",
		"'FIXED'", "'FLUSH'", "'FOLLOWING'", "'FOLLOWS'", "'FOUND'", "'FULL'",
		"'FUNCTION'", "'GENERAL'", "'GLOBAL'", "'GRANTS'", "'GROUP_REPLICATION'",
		"'HANDLER'", "'HASH'", "'HELP'", "'HISTORY'", "'HOST'", "'HOSTS'", "'IDENTIFIED'",
		"'IGNORE_SERVER_IDS'", "'IMPORT'", "'INCREMENT'", "'INDEXES'", "'INITIAL_SIZE'",
		"'INPLACE'", "'INSERT_METHOD'", "'INSTALL'", "'INSTANCE'", "'INSTANT'",
		"'INVISIBLE'", "'INVOKER'", "'IO'", "'IO_THREAD'", "'IPC'", "'ISOLATION'",
		"'ISSUER'", "'JSON'", "'KEY_BLOCK_SIZE'", "'LANGUAGE'", "'LAST'", "'LEAVES'",
		"'LESS'", "'LEVEL'", "'LIST'", "'LOCAL'", "'LOGFILE'", "'LOGS'", "'MASTER'",
		"'MASTER_AUTO_POSITION'", "'MASTER_CONNECT_RETRY'", "'MASTER_DELAY'",
		"'MASTER_HEARTBEAT_PERIOD'", "'MASTER_HOST'", "'MASTER_LOG_FILE'", "'MASTER_LOG_POS'",
		"'MASTER_PASSWORD'", "'MASTER_PORT'", "'MASTER_RETRY_COUNT'", "'MASTER_SSL'",
		"'MASTER_SSL_CA'", "'MASTER_SSL_CAPATH'", "'MASTER_SSL_CERT'", "'MASTER_SSL_CIPHER'",
		"'MASTER_SSL_CRL'", "'MASTER_SSL_CRLPATH'", "'MASTER_SSL_KEY'", "'MASTER_TLS_VERSION'",
		"'MASTER_USER'", "'MAX_CONNECTIONS_PER_HOUR'", "'MAX_QUERIES_PER_HOUR'",
		"'MAX_ROWS'", "'MAX_SIZE'", "'MAX_UPDATES_PER_HOUR'", "'MAX_USER_CONNECTIONS'",
		"'MEDIUM'", "'MEMBER'", "'MERGE'", "'MESSAGE_TEXT'", "'MID'", "'MIGRATE'",
		"'MIN_ROWS'", "'MODE'", "'MODIFY'", "'MUTEX'", "'MYSQL'", "'MYSQL_ERRNO'",
		"'NAME'", "'NAMES'", "'NCHAR'", "'NEVER'", "'NEXT'", "'NO'", "'NOCACHE'",
		"'NOCOPY'", "'NOCYCLE'", "'NOMAXVALUE'", "'NOMINVALUE'", "'NOWAIT'",
		"'NODEGROUP'", "'NONE'", "'ODBC'", "'OFFLINE'", "'OFFSET'", "'OF'",
		"'OJ'", "'OLD_PASSWORD'", "'ONE'", "'ONLINE'", "'ONLY'", "'OPEN'", "'OPTIMIZER_COSTS'",
		"'OPTIONS'", "'OWNER'", "'PACK_KEYS'", "'PAGE'", "'PAGE_COMPRESSED'",
		"'PAGE_COMPRESSION_LEVEL'", "'PARSER'", "'PARTIAL'", "'PARTITIONING'",
		"'PARTITIONS'", "'PASSWORD'", "'PASSWORD_LOCK_TIME'", "'PHASE'", "'PLUGIN'",
		"'PLUGIN_DIR'", "'PLUGINS'", "'PORT'", "'PRECEDES'", "'PRECEDING'",
		"'PREPARE'", "'PRESERVE'", "'PREV'", "'PROCESSLIST'", "'PROFILE'", "'PROFILES'",
		"'PROXY'", "'QUERY'", "'QUICK'", "'REBUILD'", "'RECOVER'", "'RECURSIVE'",
		"'REDO_BUFFER_SIZE'", "'REDUNDANT'", "'RELAY'", "'RELAY_LOG_FILE'",
		"'RELAY_LOG_POS'", "'RELAYLOG'", "'REMOVE'", "'REORGANIZE'", "'REPAIR'",
		"'REPLICATE_DO_DB'", "'REPLICATE_DO_TABLE'", "'REPLICATE_IGNORE_DB'",
		"'REPLICATE_IGNORE_TABLE'", "'REPLICATE_REWRITE_DB'", "'REPLICATE_WILD_DO_TABLE'",
		"'REPLICATE_WILD_IGNORE_TABLE'", "'REPLICATION'", "'RESET'", "'RESTART'",
		"'RESUME'", "'RETURNED_SQLSTATE'", "'RETURNING'", "'RETURNS'", "'REUSE'",
		"'ROLE'", "'ROLLBACK'", "'ROLLUP'", "'ROTATE'", "'ROW'", "'ROWS'", "'ROW_FORMAT'",
		"'RTREE'", "'SAVEPOINT'", "'SCHEDULE'", "'SECURITY'", "'SEQUENCE'",
		"'SERVER'", "'SESSION'", "'SHARE'", "'SHARED'", "'SIGNED'", "'SIMPLE'",
		"'SLAVE'", "'SLOW'", "'SNAPSHOT'", "'SOCKET'", "'SOME'", "'SONAME'",
		"'SOUNDS'", "'SOURCE'", "'SQL_AFTER_GTIDS'", "'SQL_AFTER_MTS_GAPS'",
		"'SQL_BEFORE_GTIDS'", "'SQL_BUFFER_RESULT'", "'SQL_CACHE'", "'SQL_NO_CACHE'",
		"'SQL_THREAD'", "'START'", "'STARTS'", "'STATS_AUTO_RECALC'", "'STATS_PERSISTENT'",
		"'STATS_SAMPLE_PAGES'", "'STATUS'", "'STOP'", "'STORAGE'", "'STORED'",
		"'STRING'", "'SUBCLASS_ORIGIN'", "'SUBJECT'", "'SUBPARTITION'", "'SUBPARTITIONS'",
		"'SUSPEND'", "'SWAPS'", "'SWITCHES'", "'TABLE_NAME'", "'TABLESPACE'",
		"'TABLE_TYPE'", "'TEMPORARY'", "'TEMPTABLE'", "'THAN'", "'TRADITIONAL'",
		"'TRANSACTION'", "'TRANSACTIONAL'", "'TRIGGERS'", "'TRUNCATE'", "'UNBOUNDED'",
		"'UNDEFINED'", "'UNDOFILE'", "'UNDO_BUFFER_SIZE'", "'UNINSTALL'", "'UNKNOWN'",
		"'UNTIL'", "'UPGRADE'", "'USER'", "'USE_FRM'", "'USER_RESOURCES'", "'VALIDATION'",
		"'VALUE'", "'VARIABLES'", "'VIEW'", "'VIRTUAL'", "'VISIBLE'", "'WAIT'",
		"'WARNINGS'", "'WINDOW'", "'WITHOUT'", "'WORK'", "'WRAPPER'", "'X509'",
		"'XA'", "'XML'", "'YES'", "'EUR'", "'USA'", "'JIS'", "'ISO'", "'INTERNAL'",
		"'QUARTER'", "'MONTH'", "'DAY'", "'HOUR'", "'MINUTE'", "'WEEK'", "'SECOND'",
		"'MICROSECOND'", "'ADMIN'", "'APPLICATION_PASSWORD_ADMIN'", "'AUDIT_ADMIN'",
		"'BACKUP_ADMIN'", "'BINLOG_ADMIN'", "'BINLOG_ENCRYPTION_ADMIN'", "'CLONE_ADMIN'",
		"'CONNECTION_ADMIN'", "'ENCRYPTION_KEY_ADMIN'", "'EXECUTE'", "'FILE'",
		"'FIREWALL_ADMIN'", "'FIREWALL_USER'", "'FLUSH_OPTIMIZER_COSTS'", "'FLUSH_STATUS'",
		"'FLUSH_TABLES'", "'FLUSH_USER_RESOURCES'", "'GROUP_REPLICATION_ADMIN'",
		"'INNODB_REDO_LOG_ARCHIVE'", "'INNODB_REDO_LOG_ENABLE'", "'INVOKE'",
		"'LAMBDA'", "'NDB_STORED_USER'", "'PASSWORDLESS_USER_ADMIN'", "'PERSIST_RO_VARIABLES_ADMIN'",
		"'PRIVILEGES'", "'PROCESS'", "'RELOAD'", "'REPLICATION_APPLIER'", "'REPLICATION_SLAVE_ADMIN'",
		"'RESOURCE_GROUP_ADMIN'", "'RESOURCE_GROUP_USER'", "'ROLE_ADMIN'", "'ROUTINE'",
		"'S3'", "'SERVICE_CONNECTION_ADMIN'", "", "'SET_USER_ID'", "'SHOW_ROUTINE'",
		"'SHUTDOWN'", "'SUPER'", "'SYSTEM_VARIABLES_ADMIN'", "'TABLES'", "'TABLE_ENCRYPTION_ADMIN'",
		"'VERSION_TOKEN_ADMIN'", "'XA_RECOVER_ADMIN'", "'ARMSCII8'", "'ASCII'",
		"'BIG5'", "'CP1250'", "'CP1251'", "'CP1256'", "'CP1257'", "'CP850'",
		"'CP852'", "'CP866'", "'CP932'", "'DEC8'", "'EUCJPMS'", "'EUCKR'", "'GB18030'",
		"'GB2312'", "'GBK'", "'GEOSTD8'", "'GREEK'", "'HEBREW'", "'HP8'", "'KEYBCS2'",
		"'KOI8R'", "'KOI8U'", "'LATIN1'", "'LATIN2'", "'LATIN5'", "'LATIN7'",
		"'MACCE'", "'MACROMAN'", "'SJIS'", "'SWE7'", "'TIS620'", "'UCS2'", "'UJIS'",
		"'UTF16'", "'UTF16LE'", "'UTF32'", "'UTF8'", "'UTF8MB3'", "'UTF8MB4'",
		"'ARCHIVE'", "'BLACKHOLE'", "'CSV'", "'FEDERATED'", "'INNODB'", "'MEMORY'",
		"'MRG_MYISAM'", "'MYISAM'", "'NDB'", "'NDBCLUSTER'", "'PERFORMANCE_SCHEMA'",
		"'TOKUDB'", "'REPEATABLE'", "'COMMITTED'", "'UNCOMMITTED'", "'SERIALIZABLE'",
		"'GEOMETRYCOLLECTION'", "'GEOMCOLLECTION'", "'GEOMETRY'", "'LINESTRING'",
		"'MULTILINESTRING'", "'MULTIPOINT'", "'MULTIPOLYGON'", "'POINT'", "'POLYGON'",
		"'ABS'", "'ACOS'", "'ADDDATE'", "'ADDTIME'", "'AES_DECRYPT'", "'AES_ENCRYPT'",
		"'AREA'", "'ASBINARY'", "'ASIN'", "'ASTEXT'", "'ASWKB'", "'ASWKT'",
		"'ASYMMETRIC_DECRYPT'", "'ASYMMETRIC_DERIVE'", "'ASYMMETRIC_ENCRYPT'",
		"'ASYMMETRIC_SIGN'", "'ASYMMETRIC_VERIFY'", "'ATAN'", "'ATAN2'", "'BENCHMARK'",
		"'BIN'", "'BIT_COUNT'", "'BIT_LENGTH'", "'BUFFER'", "'CATALOG_NAME'",
		"'CEIL'", "'CEILING'", "'CENTROID'", "'CHARACTER_LENGTH'", "'CHARSET'",
		"'CHAR_LENGTH'", "'COERCIBILITY'", "'COLLATION'", "'COMPRESS'", "'CONCAT'",
		"'CONCAT_WS'", "'CONNECTION_ID'", "'CONV'", "'CONVERT_TZ'", "'COS'",
		"'COT'", "'CRC32'", "'CREATE_ASYMMETRIC_PRIV_KEY'", "'CREATE_ASYMMETRIC_PUB_KEY'",
		"'CREATE_DH_PARAMETERS'", "'CREATE_DIGEST'", "'CROSSES'", "'DATEDIFF'",
		"'DATE_FORMAT'", "'DAYNAME'", "'DAYOFMONTH'", "'DAYOFWEEK'", "'DAYOFYEAR'",
		"'DECODE'", "'DEGREES'", "'DES_DECRYPT'", "'DES_ENCRYPT'", "'DIMENSION'",
		"'DISJOINT'", "'ELT'", "'ENCODE'", "'ENCRYPT'", "'ENDPOINT'", "'ENGINE_ATTRIBUTE'",
		"'ENVELOPE'", "'EQUALS'", "'EXP'", "'EXPORT_SET'", "'EXTERIORRING'",
		"'EXTRACTVALUE'", "'FIELD'", "'FIND_IN_SET'", "'FLOOR'", "'FORMAT'",
		"'FOUND_ROWS'", "'FROM_BASE64'", "'FROM_DAYS'", "'FROM_UNIXTIME'", "'GEOMCOLLFROMTEXT'",
		"'GEOMCOLLFROMWKB'", "'GEOMETRYCOLLECTIONFROMTEXT'", "'GEOMETRYCOLLECTIONFROMWKB'",
		"'GEOMETRYFROMTEXT'", "'GEOMETRYFROMWKB'", "'GEOMETRYN'", "'GEOMETRYTYPE'",
		"'GEOMFROMTEXT'", "'GEOMFROMWKB'", "'GET_FORMAT'", "'GET_LOCK'", "'GLENGTH'",
		"'GREATEST'", "'GTID_SUBSET'", "'GTID_SUBTRACT'", "'HEX'", "'IFNULL'",
		"'INET6_ATON'", "'INET6_NTOA'", "'INET_ATON'", "'INET_NTOA'", "'INSTR'",
		"'INTERIORRINGN'", "'INTERSECTS'", "'ISCLOSED'", "'ISEMPTY'", "'ISNULL'",
		"'ISSIMPLE'", "'IS_FREE_LOCK'", "'IS_IPV4'", "'IS_IPV4_COMPAT'", "'IS_IPV4_MAPPED'",
		"'IS_IPV6'", "'IS_USED_LOCK'", "'LAST_INSERT_ID'", "'LCASE'", "'LEAST'",
		"'LENGTH'", "'LINEFROMTEXT'", "'LINEFROMWKB'", "'LINESTRINGFROMTEXT'",
		"'LINESTRINGFROMWKB'", "'LN'", "'LOAD_FILE'", "'LOCATE'", "'LOG'", "'LOG10'",
		"'LOG2'", "'LOWER'", "'LPAD'", "'LTRIM'", "'MAKEDATE'", "'MAKETIME'",
		"'MAKE_SET'", "'MASTER_POS_WAIT'", "'MBRCONTAINS'", "'MBRDISJOINT'",
		"'MBREQUAL'", "'MBRINTERSECTS'", "'MBROVERLAPS'", "'MBRTOUCHES'", "'MBRWITHIN'",
		"'MD5'", "'MLINEFROMTEXT'", "'MLINEFROMWKB'", "'MONTHNAME'", "'MPOINTFROMTEXT'",
		"'MPOINTFROMWKB'", "'MPOLYFROMTEXT'", "'MPOLYFROMWKB'", "'MULTILINESTRINGFROMTEXT'",
		"'MULTILINESTRINGFROMWKB'", "'MULTIPOINTFROMTEXT'", "'MULTIPOINTFROMWKB'",
		"'MULTIPOLYGONFROMTEXT'", "'MULTIPOLYGONFROMWKB'", "'NAME_CONST'", "'NULLIF'",
		"'NUMGEOMETRIES'", "'NUMINTERIORRINGS'", "'NUMPOINTS'", "'OCT'", "'OCTET_LENGTH'",
		"'ORD'", "'OVERLAPS'", "'PERIOD_ADD'", "'PERIOD_DIFF'", "'PI'", "'POINTFROMTEXT'",
		"'POINTFROMWKB'", "'POINTN'", "'POLYFROMTEXT'", "'POLYFROMWKB'", "'POLYGONFROMTEXT'",
		"'POLYGONFROMWKB'", "'POW'", "'POWER'", "'QUOTE'", "'RADIANS'", "'RAND'",
		"'RANDOM_BYTES'", "'RELEASE_LOCK'", "'REVERSE'", "'ROUND'", "'ROW_COUNT'",
		"'RPAD'", "'RTRIM'", "'SEC_TO_TIME'", "'SECONDARY_ENGINE_ATTRIBUTE'",
		"'SESSION_USER'", "'SHA'", "'SHA1'", "'SHA2'", "'SCHEMA_NAME'", "'SIGN'",
		"'SIN'", "'SLEEP'", "'SOUNDEX'", "'SQL_THREAD_WAIT_AFTER_GTIDS'", "'SQRT'",
		"'SRID'", "'STARTPOINT'", "'STRCMP'", "'STR_TO_DATE'", "'ST_AREA'",
		"'ST_ASBINARY'", "'ST_ASTEXT'", "'ST_ASWKB'", "'ST_ASWKT'", "'ST_BUFFER'",
		"'ST_CENTROID'", "'ST_CONTAINS'", "'ST_CROSSES'", "'ST_DIFFERENCE'",
		"'ST_DIMENSION'", "'ST_DISJOINT'", "'ST_DISTANCE'", "'ST_ENDPOINT'",
		"'ST_ENVELOPE'", "'ST_EQUALS'", "'ST_EXTERIORRING'", "'ST_GEOMCOLLFROMTEXT'",
		"'ST_GEOMCOLLFROMTXT'", "'ST_GEOMCOLLFROMWKB'", "'ST_GEOMETRYCOLLECTIONFROMTEXT'",
		"'ST_GEOMETRYCOLLECTIONFROMWKB'", "'ST_GEOMETRYFROMTEXT'", "'ST_GEOMETRYFROMWKB'",
		"'ST_GEOMETRYN'", "'ST_GEOMETRYTYPE'", "'ST_GEOMFROMTEXT'", "'ST_GEOMFROMWKB'",
		"'ST_INTERIORRINGN'", "'ST_INTERSECTION'", "'ST_INTERSECTS'", "'ST_ISCLOSED'",
		"'ST_ISEMPTY'", "'ST_ISSIMPLE'", "'ST_LINEFROMTEXT'", "'ST_LINEFROMWKB'",
		"'ST_LINESTRINGFROMTEXT'", "'ST_LINESTRINGFROMWKB'", "'ST_NUMGEOMETRIES'",
		"'ST_NUMINTERIORRING'", "'ST_NUMINTERIORRINGS'", "'ST_NUMPOINTS'", "'ST_OVERLAPS'",
		"'ST_POINTFROMTEXT'", "'ST_POINTFROMWKB'", "'ST_POINTN'", "'ST_POLYFROMTEXT'",
		"'ST_POLYFROMWKB'", "'ST_POLYGONFROMTEXT'", "'ST_POLYGONFROMWKB'", "'ST_SRID'",
		"'ST_STARTPOINT'", "'ST_SYMDIFFERENCE'", "'ST_TOUCHES'", "'ST_UNION'",
		"'ST_WITHIN'", "'ST_X'", "'ST_Y'", "'SUBDATE'", "'SUBSTRING_INDEX'",
		"'SUBTIME'", "'SYSTEM_USER'", "'TAN'", "'TIMEDIFF'", "'TIMESTAMPADD'",
		"'TIMESTAMPDIFF'", "'TIME_FORMAT'", "'TIME_TO_SEC'", "'TOUCHES'", "'TO_BASE64'",
		"'TO_DAYS'", "'TO_SECONDS'", "'UCASE'", "'UNCOMPRESS'", "'UNCOMPRESSED_LENGTH'",
		"'UNHEX'", "'UNIX_TIMESTAMP'", "'UPDATEXML'", "'UPPER'", "'UUID'", "'UUID_SHORT'",
		"'VALIDATE_PASSWORD_STRENGTH'", "'VERSION'", "'WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS'",
		"'WEEKDAY'", "'WEEKOFYEAR'", "'WEIGHT_STRING'", "'WITHIN'", "'YEARWEEK'",
		"'Y'", "'X'", "':='", "'+='", "'-='", "'*='", "'/='", "'%='", "'&='",
		"'^='", "'|='", "'*'", "'/'", "'%'", "'+'", "'-'", "'DIV'", "'MOD'",
		"'='", "'>'", "'<'", "'!'", "'~'", "'|'", "'&'", "'^'", "'.'", "'('",
		"')'", "','", "';'", "'@'", "'0'", "'1'", "'2'", "'''", "'\"'", "'`'",
		"':'", "'['", "']'",
	}
	staticData.symbolicNames = []string{
		"", "SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT",
		"ADD", "ALL", "ALTER", "ALWAYS", "ANALYZE", "AND", "ARRAY", "AS", "ASC",
		"ATTRIBUTE", "BEFORE", "BETWEEN", "BOTH", "BUCKETS", "BY", "CALL", "CASCADE",
		"CASE", "CAST", "CHANGE", "CHARACTER", "CHECK", "COLLATE", "COLUMN",
		"CONDITION", "CONSTRAINT", "CONTINUE", "CONVERT", "CREATE", "CROSS",
		"CURRENT", "CURRENT_ROLE", "CURRENT_USER", "CURSOR", "DATABASE", "DATABASES",
		"DECLARE", "DEFAULT", "DELAYED", "DELETE", "DESC", "DESCRIBE", "DETERMINISTIC",
		"DIAGNOSTICS", "DISTINCT", "DISTINCTROW", "DROP", "EACH", "ELSE", "ELSEIF",
		"EMPTY", "ENCLOSED", "ESCAPED", "EXCEPT", "EXISTS", "EXIT", "EXPLAIN",
		"FALSE", "FETCH", "FOR", "FORCE", "FOREIGN", "FROM", "FULLTEXT", "GENERATED",
		"GET", "GRANT", "GROUP", "HAVING", "HIGH_PRIORITY", "HISTOGRAM", "IF",
		"IGNORE", "IGNORED", "IN", "INDEX", "INFILE", "INNER", "INOUT", "INSERT",
		"INTERVAL", "INTO", "IS", "ITERATE", "JOIN", "KEY", "KEYS", "KILL",
		"LATERAL", "LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINEAR", "LINES",
		"LOAD", "LOCK", "LOCKED", "LOOP", "LOW_PRIORITY", "MASTER_BIND", "MASTER_SSL_VERIFY_SERVER_CERT",
		"MATCH", "MAXVALUE", "MINVALUE", "MODIFIES", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG",
		"NULL_LITERAL", "NUMBER", "ON", "OPTIMIZE", "OPTION", "OPTIONAL", "OPTIONALLY",
		"OR", "ORDER", "OUT", "OUTER", "OUTFILE", "OVER", "PARTITION", "PRIMARY",
		"PROCEDURE", "PURGE", "RANGE", "READ", "READS", "REFERENCES", "REGEXP",
		"RELEASE", "RENAME", "REPEAT", "REPLACE", "REQUIRE", "RESIGNAL", "RESTRICT",
		"RETAIN", "RETURN", "REVOKE", "RIGHT", "RLIKE", "SCHEMA", "SCHEMAS",
		"SELECT", "SET", "SEPARATOR", "SHOW", "SIGNAL", "SKIP_", "SPATIAL",
		"SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT", "SQL_CALC_FOUND_ROWS",
		"SQL_SMALL_RESULT", "SSL", "STACKED", "STARTING", "STATEMENT", "STRAIGHT_JOIN",
		"TABLE", "TERMINATED", "THEN", "TO", "TRAILING", "TRIGGER", "TRUE",
		"UNDO", "UNION", "UNIQUE", "UNLOCK", "UNSIGNED", "UPDATE", "USAGE",
		"USE", "USING", "VALUES", "WHEN", "WHERE", "WHILE", "WITH", "WRITE",
		"XOR", "ZEROFILL", "ANNS", "L2", "IP", "TINYINT", "SMALLINT", "MEDIUMINT",
		"MIDDLEINT", "INT", "INT1", "INT2", "INT3", "INT4", "INT8", "INTEGER",
		"BIGINT", "REAL", "DOUBLE", "PRECISION", "FLOAT", "FLOAT4", "FLOAT8",
		"DECIMAL", "DEC", "NUMERIC", "DATE", "TIME", "TIMESTAMP", "DATETIME",
		"YEAR", "CHAR", "VARCHAR", "NVARCHAR", "NATIONAL", "BINARY", "VARBINARY",
		"TINYBLOB", "BLOB", "MEDIUMBLOB", "LONG", "LONGBLOB", "TINYTEXT", "TEXT",
		"MEDIUMTEXT", "LONGTEXT", "ENUM", "VARYING", "SERIAL", "YEAR_MONTH",
		"DAY_HOUR", "DAY_MINUTE", "DAY_SECOND", "HOUR_MINUTE", "HOUR_SECOND",
		"MINUTE_SECOND", "SECOND_MICROSECOND", "MINUTE_MICROSECOND", "HOUR_MICROSECOND",
		"DAY_MICROSECOND", "JSON_ARRAY", "JSON_ARRAYAGG", "JSON_ARRAY_APPEND",
		"JSON_ARRAY_INSERT", "JSON_CONTAINS", "JSON_CONTAINS_PATH", "JSON_DEPTH",
		"JSON_EXTRACT", "JSON_INSERT", "JSON_KEYS", "JSON_LENGTH", "JSON_MERGE",
		"JSON_MERGE_PATCH", "JSON_MERGE_PRESERVE", "JSON_OBJECT", "JSON_OBJECTAGG",
		"JSON_OVERLAPS", "JSON_PRETTY", "JSON_QUOTE", "JSON_REMOVE", "JSON_REPLACE",
		"JSON_SCHEMA_VALID", "JSON_SCHEMA_VALIDATION_REPORT", "JSON_SEARCH",
		"JSON_SET", "JSON_STORAGE_FREE", "JSON_STORAGE_SIZE", "JSON_TABLE",
		"JSON_TYPE", "JSON_UNQUOTE", "JSON_VALID", "JSON_VALUE", "NESTED", "ORDINALITY",
		"PATH", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "COUNT", "CUME_DIST",
		"DENSE_RANK", "FIRST_VALUE", "GROUP_CONCAT", "LAG", "LAST_VALUE", "LEAD",
		"MAX", "MIN", "NTILE", "NTH_VALUE", "PERCENT_RANK", "RANK", "ROW_NUMBER",
		"STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP",
		"VARIANCE", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "LOCALTIME",
		"CURDATE", "CURTIME", "DATE_ADD", "DATE_SUB", "EXTRACT", "LOCALTIMESTAMP",
		"NOW", "POSITION", "SUBSTR", "SUBSTRING", "SYSDATE", "TRIM", "UTC_DATE",
		"UTC_TIME", "UTC_TIMESTAMP", "ACCOUNT", "ACTION", "AFTER", "AGGREGATE",
		"ALGORITHM", "ANY", "AT", "AUTHORS", "AUTOCOMMIT", "AUTOEXTEND_SIZE",
		"AUTO_INCREMENT", "AVG_ROW_LENGTH", "BEGIN", "BINLOG", "BIT", "BLOCK",
		"BOOL", "BOOLEAN", "BTREE", "CACHE", "CASCADED", "CHAIN", "CHANGED",
		"CHANNEL", "CHECKSUM", "PAGE_CHECKSUM", "CIPHER", "CLASS_ORIGIN", "CLIENT",
		"CLOSE", "CLUSTERING", "COALESCE", "CODE", "COLUMNS", "COLUMN_FORMAT",
		"COLUMN_NAME", "COMMENT", "COMMIT", "COMPACT", "COMPLETION", "COMPRESSED",
		"COMPRESSION", "CONCURRENT", "CONNECT", "CONNECTION", "CONSISTENT",
		"CONSTRAINT_CATALOG", "CONSTRAINT_SCHEMA", "CONSTRAINT_NAME", "CONTAINS",
		"CONTEXT", "CONTRIBUTORS", "COPY", "CPU", "CYCLE", "CURSOR_NAME", "DATA",
		"DATAFILE", "DEALLOCATE", "DEFAULT_AUTH", "DEFINER", "DELAY_KEY_WRITE",
		"DES_KEY_FILE", "DIRECTORY", "DISABLE", "DISCARD", "DISK", "DO", "DUMPFILE",
		"DUPLICATE", "DYNAMIC", "ENABLE", "ENCRYPTED", "ENCRYPTION", "ENCRYPTION_KEY_ID",
		"END", "ENDS", "ENGINE", "ENGINES", "ERROR", "ERRORS", "ESCAPE", "EVEN",
		"EVENT", "EVENTS", "EVERY", "EXCHANGE", "EXCLUSIVE", "EXPIRE", "EXPORT",
		"EXTENDED", "EXTENT_SIZE", "FAILED_LOGIN_ATTEMPTS", "FAST", "FAULTS",
		"FIELDS", "FILE_BLOCK_SIZE", "FILTER", "FIRST", "FIXED", "FLUSH", "FOLLOWING",
		"FOLLOWS", "FOUND", "FULL", "FUNCTION", "GENERAL", "GLOBAL", "GRANTS",
		"GROUP_REPLICATION", "HANDLER", "HASH", "HELP", "HISTORY", "HOST", "HOSTS",
		"IDENTIFIED", "IGNORE_SERVER_IDS", "IMPORT", "INCREMENT", "INDEXES",
		"INITIAL_SIZE", "INPLACE", "INSERT_METHOD", "INSTALL", "INSTANCE", "INSTANT",
		"INVISIBLE", "INVOKER", "IO", "IO_THREAD", "IPC", "ISOLATION", "ISSUER",
		"JSON", "KEY_BLOCK_SIZE", "LANGUAGE", "LAST", "LEAVES", "LESS", "LEVEL",
		"LIST", "LOCAL", "LOGFILE", "LOGS", "MASTER", "MASTER_AUTO_POSITION",
		"MASTER_CONNECT_RETRY", "MASTER_DELAY", "MASTER_HEARTBEAT_PERIOD", "MASTER_HOST",
		"MASTER_LOG_FILE", "MASTER_LOG_POS", "MASTER_PASSWORD", "MASTER_PORT",
		"MASTER_RETRY_COUNT", "MASTER_SSL", "MASTER_SSL_CA", "MASTER_SSL_CAPATH",
		"MASTER_SSL_CERT", "MASTER_SSL_CIPHER", "MASTER_SSL_CRL", "MASTER_SSL_CRLPATH",
		"MASTER_SSL_KEY", "MASTER_TLS_VERSION", "MASTER_USER", "MAX_CONNECTIONS_PER_HOUR",
		"MAX_QUERIES_PER_HOUR", "MAX_ROWS", "MAX_SIZE", "MAX_UPDATES_PER_HOUR",
		"MAX_USER_CONNECTIONS", "MEDIUM", "MEMBER", "MERGE", "MESSAGE_TEXT",
		"MID", "MIGRATE", "MIN_ROWS", "MODE", "MODIFY", "MUTEX", "MYSQL", "MYSQL_ERRNO",
		"NAME", "NAMES", "NCHAR", "NEVER", "NEXT", "NO", "NOCACHE", "NOCOPY",
		"NOCYCLE", "NOMAXVALUE", "NOMINVALUE", "NOWAIT", "NODEGROUP", "NONE",
		"ODBC", "OFFLINE", "OFFSET", "OF", "OJ", "OLD_PASSWORD", "ONE", "ONLINE",
		"ONLY", "OPEN", "OPTIMIZER_COSTS", "OPTIONS", "OWNER", "PACK_KEYS",
		"PAGE", "PAGE_COMPRESSED", "PAGE_COMPRESSION_LEVEL", "PARSER", "PARTIAL",
		"PARTITIONING", "PARTITIONS", "PASSWORD", "PASSWORD_LOCK_TIME", "PHASE",
		"PLUGIN", "PLUGIN_DIR", "PLUGINS", "PORT", "PRECEDES", "PRECEDING",
		"PREPARE", "PRESERVE", "PREV", "PROCESSLIST", "PROFILE", "PROFILES",
		"PROXY", "QUERY", "QUICK", "REBUILD", "RECOVER", "RECURSIVE", "REDO_BUFFER_SIZE",
		"REDUNDANT", "RELAY", "RELAY_LOG_FILE", "RELAY_LOG_POS", "RELAYLOG",
		"REMOVE", "REORGANIZE", "REPAIR", "REPLICATE_DO_DB", "REPLICATE_DO_TABLE",
		"REPLICATE_IGNORE_DB", "REPLICATE_IGNORE_TABLE", "REPLICATE_REWRITE_DB",
		"REPLICATE_WILD_DO_TABLE", "REPLICATE_WILD_IGNORE_TABLE", "REPLICATION",
		"RESET", "RESTART", "RESUME", "RETURNED_SQLSTATE", "RETURNING", "RETURNS",
		"REUSE", "ROLE", "ROLLBACK", "ROLLUP", "ROTATE", "ROW", "ROWS", "ROW_FORMAT",
		"RTREE", "SAVEPOINT", "SCHEDULE", "SECURITY", "SEQUENCE", "SERVER",
		"SESSION", "SHARE", "SHARED", "SIGNED", "SIMPLE", "SLAVE", "SLOW", "SNAPSHOT",
		"SOCKET", "SOME", "SONAME", "SOUNDS", "SOURCE", "SQL_AFTER_GTIDS", "SQL_AFTER_MTS_GAPS",
		"SQL_BEFORE_GTIDS", "SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_NO_CACHE",
		"SQL_THREAD", "START", "STARTS", "STATS_AUTO_RECALC", "STATS_PERSISTENT",
		"STATS_SAMPLE_PAGES", "STATUS", "STOP", "STORAGE", "STORED", "STRING",
		"SUBCLASS_ORIGIN", "SUBJECT", "SUBPARTITION", "SUBPARTITIONS", "SUSPEND",
		"SWAPS", "SWITCHES", "TABLE_NAME", "TABLESPACE", "TABLE_TYPE", "TEMPORARY",
		"TEMPTABLE", "THAN", "TRADITIONAL", "TRANSACTION", "TRANSACTIONAL",
		"TRIGGERS", "TRUNCATE", "UNBOUNDED", "UNDEFINED", "UNDOFILE", "UNDO_BUFFER_SIZE",
		"UNINSTALL", "UNKNOWN", "UNTIL", "UPGRADE", "USER", "USE_FRM", "USER_RESOURCES",
		"VALIDATION", "VALUE", "VARIABLES", "VIEW", "VIRTUAL", "VISIBLE", "WAIT",
		"WARNINGS", "WINDOW", "WITHOUT", "WORK", "WRAPPER", "X509", "XA", "XML",
		"YES", "EUR", "USA", "JIS", "ISO", "INTERNAL", "QUARTER", "MONTH", "DAY",
		"HOUR", "MINUTE", "WEEK", "SECOND", "MICROSECOND", "ADMIN", "APPLICATION_PASSWORD_ADMIN",
		"AUDIT_ADMIN", "BACKUP_ADMIN", "BINLOG_ADMIN", "BINLOG_ENCRYPTION_ADMIN",
		"CLONE_ADMIN", "CONNECTION_ADMIN", "ENCRYPTION_KEY_ADMIN", "EXECUTE",
		"FILE", "FIREWALL_ADMIN", "FIREWALL_USER", "FLUSH_OPTIMIZER_COSTS",
		"FLUSH_STATUS", "FLUSH_TABLES", "FLUSH_USER_RESOURCES", "GROUP_REPLICATION_ADMIN",
		"INNODB_REDO_LOG_ARCHIVE", "INNODB_REDO_LOG_ENABLE", "INVOKE", "LAMBDA",
		"NDB_STORED_USER", "PASSWORDLESS_USER_ADMIN", "PERSIST_RO_VARIABLES_ADMIN",
		"PRIVILEGES", "PROCESS", "RELOAD", "REPLICATION_APPLIER", "REPLICATION_SLAVE_ADMIN",
		"RESOURCE_GROUP_ADMIN", "RESOURCE_GROUP_USER", "ROLE_ADMIN", "ROUTINE",
		"S3", "SERVICE_CONNECTION_ADMIN", "SESSION_VARIABLES_ADMIN", "SET_USER_ID",
		"SHOW_ROUTINE", "SHUTDOWN", "SUPER", "SYSTEM_VARIABLES_ADMIN", "TABLES",
		"TABLE_ENCRYPTION_ADMIN", "VERSION_TOKEN_ADMIN", "XA_RECOVER_ADMIN",
		"ARMSCII8", "ASCII", "BIG5", "CP1250", "CP1251", "CP1256", "CP1257",
		"CP850", "CP852", "CP866", "CP932", "DEC8", "EUCJPMS", "EUCKR", "GB18030",
		"GB2312", "GBK", "GEOSTD8", "GREEK", "HEBREW", "HP8", "KEYBCS2", "KOI8R",
		"KOI8U", "LATIN1", "LATIN2", "LATIN5", "LATIN7", "MACCE", "MACROMAN",
		"SJIS", "SWE7", "TIS620", "UCS2", "UJIS", "UTF16", "UTF16LE", "UTF32",
		"UTF8", "UTF8MB3", "UTF8MB4", "ARCHIVE", "BLACKHOLE", "CSV", "FEDERATED",
		"INNODB", "MEMORY", "MRG_MYISAM", "MYISAM", "NDB", "NDBCLUSTER", "PERFORMANCE_SCHEMA",
		"TOKUDB", "REPEATABLE", "COMMITTED", "UNCOMMITTED", "SERIALIZABLE",
		"GEOMETRYCOLLECTION", "GEOMCOLLECTION", "GEOMETRY", "LINESTRING", "MULTILINESTRING",
		"MULTIPOINT", "MULTIPOLYGON", "POINT", "POLYGON", "ABS", "ACOS", "ADDDATE",
		"ADDTIME", "AES_DECRYPT", "AES_ENCRYPT", "AREA", "ASBINARY", "ASIN",
		"ASTEXT", "ASWKB", "ASWKT", "ASYMMETRIC_DECRYPT", "ASYMMETRIC_DERIVE",
		"ASYMMETRIC_ENCRYPT", "ASYMMETRIC_SIGN", "ASYMMETRIC_VERIFY", "ATAN",
		"ATAN2", "BENCHMARK", "BIN", "BIT_COUNT", "BIT_LENGTH", "BUFFER", "CATALOG_NAME",
		"CEIL", "CEILING", "CENTROID", "CHARACTER_LENGTH", "CHARSET", "CHAR_LENGTH",
		"COERCIBILITY", "COLLATION", "COMPRESS", "CONCAT", "CONCAT_WS", "CONNECTION_ID",
		"CONV", "CONVERT_TZ", "COS", "COT", "CRC32", "CREATE_ASYMMETRIC_PRIV_KEY",
		"CREATE_ASYMMETRIC_PUB_KEY", "CREATE_DH_PARAMETERS", "CREATE_DIGEST",
		"CROSSES", "DATEDIFF", "DATE_FORMAT", "DAYNAME", "DAYOFMONTH", "DAYOFWEEK",
		"DAYOFYEAR", "DECODE", "DEGREES", "DES_DECRYPT", "DES_ENCRYPT", "DIMENSION",
		"DISJOINT", "ELT", "ENCODE", "ENCRYPT", "ENDPOINT", "ENGINE_ATTRIBUTE",
		"ENVELOPE", "EQUALS", "EXP", "EXPORT_SET", "EXTERIORRING", "EXTRACTVALUE",
		"FIELD", "FIND_IN_SET", "FLOOR", "FORMAT", "FOUND_ROWS", "FROM_BASE64",
		"FROM_DAYS", "FROM_UNIXTIME", "GEOMCOLLFROMTEXT", "GEOMCOLLFROMWKB",
		"GEOMETRYCOLLECTIONFROMTEXT", "GEOMETRYCOLLECTIONFROMWKB", "GEOMETRYFROMTEXT",
		"GEOMETRYFROMWKB", "GEOMETRYN", "GEOMETRYTYPE", "GEOMFROMTEXT", "GEOMFROMWKB",
		"GET_FORMAT", "GET_LOCK", "GLENGTH", "GREATEST", "GTID_SUBSET", "GTID_SUBTRACT",
		"HEX", "IFNULL", "INET6_ATON", "INET6_NTOA", "INET_ATON", "INET_NTOA",
		"INSTR", "INTERIORRINGN", "INTERSECTS", "ISCLOSED", "ISEMPTY", "ISNULL",
		"ISSIMPLE", "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED",
		"IS_IPV6", "IS_USED_LOCK", "LAST_INSERT_ID", "LCASE", "LEAST", "LENGTH",
		"LINEFROMTEXT", "LINEFROMWKB", "LINESTRINGFROMTEXT", "LINESTRINGFROMWKB",
		"LN", "LOAD_FILE", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD",
		"LTRIM", "MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_POS_WAIT", "MBRCONTAINS",
		"MBRDISJOINT", "MBREQUAL", "MBRINTERSECTS", "MBROVERLAPS", "MBRTOUCHES",
		"MBRWITHIN", "MD5", "MLINEFROMTEXT", "MLINEFROMWKB", "MONTHNAME", "MPOINTFROMTEXT",
		"MPOINTFROMWKB", "MPOLYFROMTEXT", "MPOLYFROMWKB", "MULTILINESTRINGFROMTEXT",
		"MULTILINESTRINGFROMWKB", "MULTIPOINTFROMTEXT", "MULTIPOINTFROMWKB",
		"MULTIPOLYGONFROMTEXT", "MULTIPOLYGONFROMWKB", "NAME_CONST", "NULLIF",
		"NUMGEOMETRIES", "NUMINTERIORRINGS", "NUMPOINTS", "OCT", "OCTET_LENGTH",
		"ORD", "OVERLAPS", "PERIOD_ADD", "PERIOD_DIFF", "PI", "POINTFROMTEXT",
		"POINTFROMWKB", "POINTN", "POLYFROMTEXT", "POLYFROMWKB", "POLYGONFROMTEXT",
		"POLYGONFROMWKB", "POW", "POWER", "QUOTE", "RADIANS", "RAND", "RANDOM_BYTES",
		"RELEASE_LOCK", "REVERSE", "ROUND", "ROW_COUNT", "RPAD", "RTRIM", "SEC_TO_TIME",
		"SECONDARY_ENGINE_ATTRIBUTE", "SESSION_USER", "SHA", "SHA1", "SHA2",
		"SCHEMA_NAME", "SIGN", "SIN", "SLEEP", "SOUNDEX", "SQL_THREAD_WAIT_AFTER_GTIDS",
		"SQRT", "SRID", "STARTPOINT", "STRCMP", "STR_TO_DATE", "ST_AREA", "ST_ASBINARY",
		"ST_ASTEXT", "ST_ASWKB", "ST_ASWKT", "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS",
		"ST_CROSSES", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE",
		"ST_ENDPOINT", "ST_ENVELOPE", "ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMCOLLFROMTEXT",
		"ST_GEOMCOLLFROMTXT", "ST_GEOMCOLLFROMWKB", "ST_GEOMETRYCOLLECTIONFROMTEXT",
		"ST_GEOMETRYCOLLECTIONFROMWKB", "ST_GEOMETRYFROMTEXT", "ST_GEOMETRYFROMWKB",
		"ST_GEOMETRYN", "ST_GEOMETRYTYPE", "ST_GEOMFROMTEXT", "ST_GEOMFROMWKB",
		"ST_INTERIORRINGN", "ST_INTERSECTION", "ST_INTERSECTS", "ST_ISCLOSED",
		"ST_ISEMPTY", "ST_ISSIMPLE", "ST_LINEFROMTEXT", "ST_LINEFROMWKB", "ST_LINESTRINGFROMTEXT",
		"ST_LINESTRINGFROMWKB", "ST_NUMGEOMETRIES", "ST_NUMINTERIORRING", "ST_NUMINTERIORRINGS",
		"ST_NUMPOINTS", "ST_OVERLAPS", "ST_POINTFROMTEXT", "ST_POINTFROMWKB",
		"ST_POINTN", "ST_POLYFROMTEXT", "ST_POLYFROMWKB", "ST_POLYGONFROMTEXT",
		"ST_POLYGONFROMWKB", "ST_SRID", "ST_STARTPOINT", "ST_SYMDIFFERENCE",
		"ST_TOUCHES", "ST_UNION", "ST_WITHIN", "ST_X", "ST_Y", "SUBDATE", "SUBSTRING_INDEX",
		"SUBTIME", "SYSTEM_USER", "TAN", "TIMEDIFF", "TIMESTAMPADD", "TIMESTAMPDIFF",
		"TIME_FORMAT", "TIME_TO_SEC", "TOUCHES", "TO_BASE64", "TO_DAYS", "TO_SECONDS",
		"UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP",
		"UPDATEXML", "UPPER", "UUID", "UUID_SHORT", "VALIDATE_PASSWORD_STRENGTH",
		"VERSION", "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS", "WEEKDAY", "WEEKOFYEAR",
		"WEIGHT_STRING", "WITHIN", "YEARWEEK", "Y_FUNCTION", "X_FUNCTION", "VAR_ASSIGN",
		"PLUS_ASSIGN", "MINUS_ASSIGN", "MULT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN",
		"AND_ASSIGN", "XOR_ASSIGN", "OR_ASSIGN", "STAR", "DIVIDE", "MODULE",
		"PLUS", "MINUS", "DIV", "MOD", "EQUAL_SYMBOL", "GREATER_SYMBOL", "LESS_SYMBOL",
		"EXCLAMATION_SYMBOL", "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP", "BIT_XOR_OP",
		"DOT", "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "AT_SIGN", "ZERO_DECIMAL",
		"ONE_DECIMAL", "TWO_DECIMAL", "SINGLE_QUOTE_SYMB", "DOUBLE_QUOTE_SYMB",
		"REVERSE_QUOTE_SYMB", "COLON_SYMB", "LR_BRACKETS", "RR_BRACKETS", "CHARSET_REVERSE_QOUTE_STRING",
		"FILESIZE_LITERAL", "START_NATIONAL_STRING_LITERAL", "STRING_LITERAL",
		"DECIMAL_LITERAL", "HEXADECIMAL_LITERAL", "REAL_LITERAL", "NULL_SPEC_LITERAL",
		"BIT_STRING", "STRING_CHARSET_NAME", "DOT_ID", "ID", "REVERSE_QUOTE_ID",
		"STRING_USER_NAME", "IP_ADDRESS", "LOCAL_ID", "GLOBAL_ID", "ERROR_RECONGNIGION",
	}
	staticData.ruleNames = []string{
		"root", "sqlStatements", "sqlStatement", "emptyStatement_", "dmlStatement",
		"selectStatement", "lockClause", "tableSources", "tableSource", "querySpecification",
		"selectSpec", "selectElements", "selectElement", "fromClause", "annsClause",
		"annsFuncClause", "annsArgs", "limitClause", "limitClauseAtom", "fullId",
		"tableName", "fullColumnName", "collationName", "uid", "simpleId", "dottedId",
		"decimalLiteral", "stringLiteral", "booleanLiteral", "hexadecimalLiteral",
		"constant", "expressions", "functionCall", "aggregateWindowedFunction",
		"expression", "predicate", "expressionAtom", "array", "unaryOperator",
		"comparisonOperator", "logicalOperator",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 1160, 441, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 1, 0, 3, 0,
		84, 8, 0, 1, 0, 1, 0, 3, 0, 88, 8, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 3,
		1, 95, 8, 1, 1, 1, 3, 1, 98, 8, 1, 1, 1, 5, 1, 101, 8, 1, 10, 1, 12, 1,
		104, 9, 1, 1, 1, 1, 1, 1, 1, 3, 1, 109, 8, 1, 1, 1, 3, 1, 112, 8, 1, 1,
		1, 3, 1, 115, 8, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 4, 1, 4, 1, 5, 1, 5, 3,
		5, 125, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 133, 8, 6, 1, 7,
		1, 7, 1, 7, 5, 7, 138, 8, 7, 10, 7, 12, 7, 141, 9, 7, 1, 8, 1, 8, 1, 9,
		1, 9, 5, 9, 147, 8, 9, 10, 9, 12, 9, 150, 9, 9, 1, 9, 1, 9, 3, 9, 154,
		8, 9, 1, 9, 3, 9, 157, 8, 9, 1, 9, 3, 9, 160, 8, 9, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 170, 8, 10, 1, 11, 1, 11, 3,
		11, 174, 8, 11, 1, 11, 1, 11, 5, 11, 178, 8, 11, 10, 11, 12, 11, 181, 9,
		11, 1, 12, 1, 12, 3, 12, 185, 8, 12, 1, 12, 3, 12, 188, 8, 12, 1, 12, 1,
		12, 3, 12, 192, 8, 12, 1, 12, 3, 12, 195, 8, 12, 3, 12, 197, 8, 12, 1,
		13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 204, 8, 13, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 5, 16, 218,
		8, 16, 10, 16, 12, 16, 221, 9, 16, 3, 16, 223, 8, 16, 1, 17, 1, 17, 1,
		17, 1, 17, 3, 17, 229, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17,
		236, 8, 17, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 244, 8, 19,
		1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 3, 21, 251, 8, 21, 3, 21, 253, 8, 21,
		1, 21, 3, 21, 256, 8, 21, 1, 21, 1, 21, 3, 21, 260, 8, 21, 3, 21, 262,
		8, 21, 1, 22, 1, 22, 3, 22, 266, 8, 22, 1, 23, 1, 23, 1, 23, 3, 23, 271,
		8, 23, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 3, 25, 278, 8, 25, 1, 26, 1,
		26, 1, 27, 3, 27, 283, 8, 27, 1, 27, 1, 27, 3, 27, 287, 8, 27, 1, 27, 4,
		27, 290, 8, 27, 11, 27, 12, 27, 291, 1, 27, 3, 27, 295, 8, 27, 1, 27, 1,
		27, 3, 27, 299, 8, 27, 1, 27, 1, 27, 3, 27, 303, 8, 27, 3, 27, 305, 8,
		27, 1, 28, 1, 28, 1, 29, 3, 29, 310, 8, 29, 1, 29, 1, 29, 1, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 322, 8, 30, 1, 31, 1,
		31, 1, 31, 5, 31, 327, 8, 31, 10, 31, 12, 31, 330, 9, 31, 1, 32, 1, 32,
		1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1,
		34, 3, 34, 345, 8, 34, 1, 34, 1, 34, 1, 34, 3, 34, 350, 8, 34, 1, 34, 1,
		34, 1, 34, 1, 34, 5, 34, 356, 8, 34, 10, 34, 12, 34, 359, 9, 34, 1, 35,
		1, 35, 1, 35, 3, 35, 364, 8, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1,
		35, 1, 35, 1, 35, 3, 35, 374, 8, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35,
		5, 35, 381, 8, 35, 10, 35, 12, 35, 384, 9, 35, 1, 36, 1, 36, 1, 36, 1,
		36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 5, 36, 395, 8, 36, 10, 36, 12, 36,
		398, 9, 36, 1, 36, 1, 36, 1, 36, 3, 36, 403, 8, 36, 1, 37, 1, 37, 1, 37,
		1, 37, 5, 37, 409, 8, 37, 10, 37, 12, 37, 412, 9, 37, 3, 37, 414, 8, 37,
		1, 37, 1, 37, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 431, 8, 39, 1, 40, 1, 40, 1, 40,
		1, 40, 1, 40, 1, 40, 3, 40, 439, 8, 40, 1, 40, 0, 2, 68, 70, 41, 0, 2,
		4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40,
		42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76,
		78, 80, 0, 8, 2, 0, 6, 6, 49, 50, 1, 0, 627, 628, 1, 0, 195, 196, 3, 0,
		1134, 1136, 1147, 1147, 1149, 1149, 2, 0, 62, 62, 176, 176, 2, 0, 113,
		113, 1123, 1123, 3, 0, 62, 62, 176, 176, 663, 663, 3, 0, 113, 113, 1116,
		1117, 1123, 1124, 484, 0, 83, 1, 0, 0, 0, 2, 102, 1, 0, 0, 0, 4, 116, 1,
		0, 0, 0, 6, 118, 1, 0, 0, 0, 8, 120, 1, 0, 0, 0, 10, 122, 1, 0, 0, 0, 12,
		132, 1, 0, 0, 0, 14, 134, 1, 0, 0, 0, 16, 142, 1, 0, 0, 0, 18, 144, 1,
		0, 0, 0, 20, 169, 1, 0, 0, 0, 22, 173, 1, 0, 0, 0, 24, 196, 1, 0, 0, 0,
		26, 198, 1, 0, 0, 0, 28, 205, 1, 0, 0, 0, 30, 209, 1, 0, 0, 0, 32, 222,
		1, 0, 0, 0, 34, 224, 1, 0, 0, 0, 36, 237, 1, 0, 0, 0, 38, 239, 1, 0, 0,
		0, 40, 245, 1, 0, 0, 0, 42, 261, 1, 0, 0, 0, 44, 265, 1, 0, 0, 0, 46, 270,
		1, 0, 0, 0, 48, 272, 1, 0, 0, 0, 50, 277, 1, 0, 0, 0, 52, 279, 1, 0, 0,
		0, 54, 304, 1, 0, 0, 0, 56, 306, 1, 0, 0, 0, 58, 309, 1, 0, 0, 0, 60, 321,
		1, 0, 0, 0, 62, 323, 1, 0, 0, 0, 64, 331, 1, 0, 0, 0, 66, 333, 1, 0, 0,
		0, 68, 349, 1, 0, 0, 0, 70, 360, 1, 0, 0, 0, 72, 402, 1, 0, 0, 0, 74, 404,
		1, 0, 0, 0, 76, 417, 1, 0, 0, 0, 78, 430, 1, 0, 0, 0, 80, 438, 1, 0, 0,
		0, 82, 84, 3, 2, 1, 0, 83, 82, 1, 0, 0, 0, 83, 84, 1, 0, 0, 0, 84, 87,
		1, 0, 0, 0, 85, 86, 5, 1117, 0, 0, 86, 88, 5, 1117, 0, 0, 87, 85, 1, 0,
		0, 0, 87, 88, 1, 0, 0, 0, 88, 89, 1, 0, 0, 0, 89, 90, 5, 0, 0, 1, 90, 1,
		1, 0, 0, 0, 91, 94, 3, 4, 2, 0, 92, 93, 5, 1117, 0, 0, 93, 95, 5, 1117,
		0, 0, 94, 92, 1, 0, 0, 0, 94, 95, 1, 0, 0, 0, 95, 97, 1, 0, 0, 0, 96, 98,
		5, 1132, 0, 0, 97, 96, 1, 0, 0, 0, 97, 98, 1, 0, 0, 0, 98, 101, 1, 0, 0,
		0, 99, 101, 3, 6, 3, 0, 100, 91, 1, 0, 0, 0, 100, 99, 1, 0, 0, 0, 101,
		104, 1, 0, 0, 0, 102, 100, 1, 0, 0, 0, 102, 103, 1, 0, 0, 0, 103, 114,
		1, 0, 0, 0, 104, 102, 1, 0, 0, 0, 105, 111, 3, 4, 2, 0, 106, 107, 5, 1117,
		0, 0, 107, 109, 5, 1117, 0, 0, 108, 106, 1, 0, 0, 0, 108, 109, 1, 0, 0,
		0, 109, 110, 1, 0, 0, 0, 110, 112, 5, 1132, 0, 0, 111, 108, 1, 0, 0, 0,
		111, 112, 1, 0, 0, 0, 112, 115, 1, 0, 0, 0, 113, 115, 3, 6, 3, 0, 114,
		105, 1, 0, 0, 0, 114, 113, 1, 0, 0, 0, 115, 3, 1, 0, 0, 0, 116, 117, 3,
		8, 4, 0, 117, 5, 1, 0, 0, 0, 118, 119, 5, 1132, 0, 0, 119, 7, 1, 0, 0,
		0, 120, 121, 3, 10, 5, 0, 121, 9, 1, 0, 0, 0, 122, 124, 3, 18, 9, 0, 123,
		125, 3, 12, 6, 0, 124, 123, 1, 0, 0, 0, 124, 125, 1, 0, 0, 0, 125, 11,
		1, 0, 0, 0, 126, 127, 5, 64, 0, 0, 127, 133, 5, 182, 0, 0, 128, 129, 5,
		102, 0, 0, 129, 130, 5, 79, 0, 0, 130, 131, 5, 611, 0, 0, 131, 133, 5,
		512, 0, 0, 132, 126, 1, 0, 0, 0, 132, 128, 1, 0, 0, 0, 133, 13, 1, 0, 0,
		0, 134, 139, 3, 16, 8, 0, 135, 136, 5, 1131, 0, 0, 136, 138, 3, 16, 8,
		0, 137, 135, 1, 0, 0, 0, 138, 141, 1, 0, 0, 0, 139, 137, 1, 0, 0, 0, 139,
		140, 1, 0, 0, 0, 140, 15, 1, 0, 0, 0, 141, 139, 1, 0, 0, 0, 142, 143, 3,
		40, 20, 0, 143, 17, 1, 0, 0, 0, 144, 148, 5, 151, 0, 0, 145, 147, 3, 20,
		10, 0, 146, 145, 1, 0, 0, 0, 147, 150, 1, 0, 0, 0, 148, 146, 1, 0, 0, 0,
		148, 149, 1, 0, 0, 0, 149, 151, 1, 0, 0, 0, 150, 148, 1, 0, 0, 0, 151,
		153, 3, 22, 11, 0, 152, 154, 3, 26, 13, 0, 153, 152, 1, 0, 0, 0, 153, 154,
		1, 0, 0, 0, 154, 156, 1, 0, 0, 0, 155, 157, 3, 28, 14, 0, 156, 155, 1,
		0, 0, 0, 156, 157, 1, 0, 0, 0, 157, 159, 1, 0, 0, 0, 158, 160, 3, 34, 17,
		0, 159, 158, 1, 0, 0, 0, 159, 160, 1, 0, 0, 0, 160, 19, 1, 0, 0, 0, 161,
		170, 7, 0, 0, 0, 162, 170, 5, 74, 0, 0, 163, 170, 5, 169, 0, 0, 164, 170,
		5, 164, 0, 0, 165, 170, 5, 162, 0, 0, 166, 170, 5, 626, 0, 0, 167, 170,
		7, 1, 0, 0, 168, 170, 5, 163, 0, 0, 169, 161, 1, 0, 0, 0, 169, 162, 1,
		0, 0, 0, 169, 163, 1, 0, 0, 0, 169, 164, 1, 0, 0, 0, 169, 165, 1, 0, 0,
		0, 169, 166, 1, 0, 0, 0, 169, 167, 1, 0, 0, 0, 169, 168, 1, 0, 0, 0, 170,
		21, 1, 0, 0, 0, 171, 174, 5, 1113, 0, 0, 172, 174, 3, 24, 12, 0, 173, 171,
		1, 0, 0, 0, 173, 172, 1, 0, 0, 0, 174, 179, 1, 0, 0, 0, 175, 176, 5, 1131,
		0, 0, 176, 178, 3, 24, 12, 0, 177, 175, 1, 0, 0, 0, 178, 181, 1, 0, 0,
		0, 179, 177, 1, 0, 0, 0, 179, 180, 1, 0, 0, 0, 180, 23, 1, 0, 0, 0, 181,
		179, 1, 0, 0, 0, 182, 187, 3, 42, 21, 0, 183, 185, 5, 12, 0, 0, 184, 183,
		1, 0, 0, 0, 184, 185, 1, 0, 0, 0, 185, 186, 1, 0, 0, 0, 186, 188, 3, 46,
		23, 0, 187, 184, 1, 0, 0, 0, 187, 188, 1, 0, 0, 0, 188, 197, 1, 0, 0, 0,
		189, 194, 3, 64, 32, 0, 190, 192, 5, 12, 0, 0, 191, 190, 1, 0, 0, 0, 191,
		192, 1, 0, 0, 0, 192, 193, 1, 0, 0, 0, 193, 195, 3, 46, 23, 0, 194, 191,
		1, 0, 0, 0, 194, 195, 1, 0, 0, 0, 195, 197, 1, 0, 0, 0, 196, 182, 1, 0,
		0, 0, 196, 189, 1, 0, 0, 0, 197, 25, 1, 0, 0, 0, 198, 199, 5, 67, 0, 0,
		199, 200, 3, 14, 7, 0, 200, 203, 1, 0, 0, 0, 201, 202, 5, 188, 0, 0, 202,
		204, 3, 68, 34, 0, 203, 201, 1, 0, 0, 0, 203, 204, 1, 0, 0, 0, 204, 27,
		1, 0, 0, 0, 205, 206, 5, 194, 0, 0, 206, 207, 5, 19, 0, 0, 207, 208, 3,
		30, 15, 0, 208, 29, 1, 0, 0, 0, 209, 210, 7, 2, 0, 0, 210, 211, 5, 1129,
		0, 0, 211, 212, 3, 32, 16, 0, 212, 213, 5, 1130, 0, 0, 213, 31, 1, 0, 0,
		0, 214, 219, 3, 68, 34, 0, 215, 216, 5, 1131, 0, 0, 216, 218, 3, 68, 34,
		0, 217, 215, 1, 0, 0, 0, 218, 221, 1, 0, 0, 0, 219, 217, 1, 0, 0, 0, 219,
		220, 1, 0, 0, 0, 220, 223, 1, 0, 0, 0, 221, 219, 1, 0, 0, 0, 222, 214,
		1, 0, 0, 0, 222, 223, 1, 0, 0, 0, 223, 33, 1, 0, 0, 0, 224, 235, 5, 98,
		0, 0, 225, 226, 3, 36, 18, 0, 226, 227, 5, 1131, 0, 0, 227, 229, 1, 0,
		0, 0, 228, 225, 1, 0, 0, 0, 228, 229, 1, 0, 0, 0, 229, 230, 1, 0, 0, 0,
		230, 236, 3, 36, 18, 0, 231, 232, 3, 36, 18, 0, 232, 233, 5, 533, 0, 0,
		233, 234, 3, 36, 18, 0, 234, 236, 1, 0, 0, 0, 235, 228, 1, 0, 0, 0, 235,
		231, 1, 0, 0, 0, 236, 35, 1, 0, 0, 0, 237, 238, 3, 52, 26, 0, 238, 37,
		1, 0, 0, 0, 239, 243, 3, 46, 23, 0, 240, 244, 5, 1153, 0, 0, 241, 242,
		5, 1128, 0, 0, 242, 244, 3, 46, 23, 0, 243, 240, 1, 0, 0, 0, 243, 241,
		1, 0, 0, 0, 243, 244, 1, 0, 0, 0, 244, 39, 1, 0, 0, 0, 245, 246, 3, 38,
		19, 0, 246, 41, 1, 0, 0, 0, 247, 252, 3, 46, 23, 0, 248, 250, 3, 50, 25,
		0, 249, 251, 3, 50, 25, 0, 250, 249, 1, 0, 0, 0, 250, 251, 1, 0, 0, 0,
		251, 253, 1, 0, 0, 0, 252, 248, 1, 0, 0, 0, 252, 253, 1, 0, 0, 0, 253,
		262, 1, 0, 0, 0, 254, 256, 9, 0, 0, 0, 255, 254, 1, 0, 0, 0, 255, 256,
		1, 0, 0, 0, 256, 257, 1, 0, 0, 0, 257, 259, 3, 50, 25, 0, 258, 260, 3,
		50, 25, 0, 259, 258, 1, 0, 0, 0, 259, 260, 1, 0, 0, 0, 260, 262, 1, 0,
		0, 0, 261, 247, 1, 0, 0, 0, 261, 255, 1, 0, 0, 0, 262, 43, 1, 0, 0, 0,
		263, 266, 3, 46, 23, 0, 264, 266, 5, 1146, 0, 0, 265, 263, 1, 0, 0, 0,
		265, 264, 1, 0, 0, 0, 266, 45, 1, 0, 0, 0, 267, 271, 3, 48, 24, 0, 268,
		271, 5, 1155, 0, 0, 269, 271, 5, 1143, 0, 0, 270, 267, 1, 0, 0, 0, 270,
		268, 1, 0, 0, 0, 270, 269, 1, 0, 0, 0, 271, 47, 1, 0, 0, 0, 272, 273, 5,
		1154, 0, 0, 273, 49, 1, 0, 0, 0, 274, 278, 5, 1153, 0, 0, 275, 276, 5,
		1128, 0, 0, 276, 278, 3, 46, 23, 0, 277, 274, 1, 0, 0, 0, 277, 275, 1,
		0, 0, 0, 278, 51, 1, 0, 0, 0, 279, 280, 7, 3, 0, 0, 280, 53, 1, 0, 0, 0,
		281, 283, 5, 1152, 0, 0, 282, 281, 1, 0, 0, 0, 282, 283, 1, 0, 0, 0, 283,
		284, 1, 0, 0, 0, 284, 287, 5, 1146, 0, 0, 285, 287, 5, 1145, 0, 0, 286,
		282, 1, 0, 0, 0, 286, 285, 1, 0, 0, 0, 287, 289, 1, 0, 0, 0, 288, 290,
		5, 1146, 0, 0, 289, 288, 1, 0, 0, 0, 290, 291, 1, 0, 0, 0, 291, 289, 1,
		0, 0, 0, 291, 292, 1, 0, 0, 0, 292, 305, 1, 0, 0, 0, 293, 295, 5, 1152,
		0, 0, 294, 293, 1, 0, 0, 0, 294, 295, 1, 0, 0, 0, 295, 296, 1, 0, 0, 0,
		296, 299, 5, 1146, 0, 0, 297, 299, 5, 1145, 0, 0, 298, 294, 1, 0, 0, 0,
		298, 297, 1, 0, 0, 0, 299, 302, 1, 0, 0, 0, 300, 301, 5, 27, 0, 0, 301,
		303, 3, 44, 22, 0, 302, 300, 1, 0, 0, 0, 302, 303, 1, 0, 0, 0, 303, 305,
		1, 0, 0, 0, 304, 286, 1, 0, 0, 0, 304, 298, 1, 0, 0, 0, 305, 55, 1, 0,
		0, 0, 306, 307, 7, 4, 0, 0, 307, 57, 1, 0, 0, 0, 308, 310, 5, 1152, 0,
		0, 309, 308, 1, 0, 0, 0, 309, 310, 1, 0, 0, 0, 310, 311, 1, 0, 0, 0, 311,
		312, 5, 1148, 0, 0, 312, 59, 1, 0, 0, 0, 313, 322, 3, 54, 27, 0, 314, 322,
		3, 52, 26, 0, 315, 316, 5, 1117, 0, 0, 316, 322, 3, 52, 26, 0, 317, 322,
		3, 58, 29, 0, 318, 322, 3, 56, 28, 0, 319, 322, 5, 1149, 0, 0, 320, 322,
		5, 1151, 0, 0, 321, 313, 1, 0, 0, 0, 321, 314, 1, 0, 0, 0, 321, 315, 1,
		0, 0, 0, 321, 317, 1, 0, 0, 0, 321, 318, 1, 0, 0, 0, 321, 319, 1, 0, 0,
		0, 321, 320, 1, 0, 0, 0, 322, 61, 1, 0, 0, 0, 323, 328, 3, 68, 34, 0, 324,
		325, 5, 1131, 0, 0, 325, 327, 3, 68, 34, 0, 326, 324, 1, 0, 0, 0, 327,
		330, 1, 0, 0, 0, 328, 326, 1, 0, 0, 0, 328, 329, 1, 0, 0, 0, 329, 63, 1,
		0, 0, 0, 330, 328, 1, 0, 0, 0, 331, 332, 3, 66, 33, 0, 332, 65, 1, 0, 0,
		0, 333, 334, 5, 291, 0, 0, 334, 335, 5, 1129, 0, 0, 335, 336, 5, 1113,
		0, 0, 336, 337, 5, 1130, 0, 0, 337, 67, 1, 0, 0, 0, 338, 339, 6, 34, -1,
		0, 339, 340, 7, 5, 0, 0, 340, 350, 3, 68, 34, 4, 341, 342, 3, 70, 35, 0,
		342, 344, 5, 87, 0, 0, 343, 345, 5, 113, 0, 0, 344, 343, 1, 0, 0, 0, 344,
		345, 1, 0, 0, 0, 345, 346, 1, 0, 0, 0, 346, 347, 7, 6, 0, 0, 347, 350,
		1, 0, 0, 0, 348, 350, 3, 70, 35, 0, 349, 338, 1, 0, 0, 0, 349, 341, 1,
		0, 0, 0, 349, 348, 1, 0, 0, 0, 350, 357, 1, 0, 0, 0, 351, 352, 10, 3, 0,
		0, 352, 353, 3, 80, 40, 0, 353, 354, 3, 68, 34, 4, 354, 356, 1, 0, 0, 0,
		355, 351, 1, 0, 0, 0, 356, 359, 1, 0, 0, 0, 357, 355, 1, 0, 0, 0, 357,
		358, 1, 0, 0, 0, 358, 69, 1, 0, 0, 0, 359, 357, 1, 0, 0, 0, 360, 363, 6,
		35, -1, 0, 361, 362, 5, 1158, 0, 0, 362, 364, 5, 1104, 0, 0, 363, 361,
		1, 0, 0, 0, 363, 364, 1, 0, 0, 0, 364, 365, 1, 0, 0, 0, 365, 366, 3, 72,
		36, 0, 366, 382, 1, 0, 0, 0, 367, 368, 10, 2, 0, 0, 368, 369, 3, 78, 39,
		0, 369, 370, 3, 70, 35, 3, 370, 381, 1, 0, 0, 0, 371, 373, 10, 3, 0, 0,
		372, 374, 5, 113, 0, 0, 373, 372, 1, 0, 0, 0, 373, 374, 1, 0, 0, 0, 374,
		375, 1, 0, 0, 0, 375, 376, 5, 79, 0, 0, 376, 377, 5, 1129, 0, 0, 377, 378,
		3, 62, 31, 0, 378, 379, 5, 1130, 0, 0, 379, 381, 1, 0, 0, 0, 380, 367,
		1, 0, 0, 0, 380, 371, 1, 0, 0, 0, 381, 384, 1, 0, 0, 0, 382, 380, 1, 0,
		0, 0, 382, 383, 1, 0, 0, 0, 383, 71, 1, 0, 0, 0, 384, 382, 1, 0, 0, 0,
		385, 403, 3, 60, 30, 0, 386, 403, 3, 42, 21, 0, 387, 388, 3, 76, 38, 0,
		388, 389, 3, 72, 36, 0, 389, 403, 1, 0, 0, 0, 390, 391, 5, 1129, 0, 0,
		391, 396, 3, 68, 34, 0, 392, 393, 5, 1131, 0, 0, 393, 395, 3, 68, 34, 0,
		394, 392, 1, 0, 0, 0, 395, 398, 1, 0, 0, 0, 396, 394, 1, 0, 0, 0, 396,
		397, 1, 0, 0, 0, 397, 399, 1, 0, 0, 0, 398, 396, 1, 0, 0, 0, 399, 400,
		5, 1130, 0, 0, 400, 403, 1, 0, 0, 0, 401, 403, 3, 74, 37, 0, 402, 385,
		1, 0, 0, 0, 402, 386, 1, 0, 0, 0, 402, 387, 1, 0, 0, 0, 402, 390, 1, 0,
		0, 0, 402, 401, 1, 0, 0, 0, 403, 73, 1, 0, 0, 0, 404, 413, 5, 1141, 0,
		0, 405, 410, 3, 68, 34, 0, 406, 407, 5, 1131, 0, 0, 407, 409, 3, 68, 34,
		0, 408, 406, 1, 0, 0, 0, 409, 412, 1, 0, 0, 0, 410, 408, 1, 0, 0, 0, 410,
		411, 1, 0, 0, 0, 411, 414, 1, 0, 0, 0, 412, 410, 1, 0, 0, 0, 413, 405,
		1, 0, 0, 0, 413, 414, 1, 0, 0, 0, 414, 415, 1, 0, 0, 0, 415, 416, 5, 1142,
		0, 0, 416, 75, 1, 0, 0, 0, 417, 418, 7, 7, 0, 0, 418, 77, 1, 0, 0, 0, 419,
		431, 5, 1120, 0, 0, 420, 431, 5, 1121, 0, 0, 421, 431, 5, 1122, 0, 0, 422,
		423, 5, 1122, 0, 0, 423, 431, 5, 1120, 0, 0, 424, 425, 5, 1121, 0, 0, 425,
		431, 5, 1120, 0, 0, 426, 427, 5, 1122, 0, 0, 427, 431, 5, 1121, 0, 0, 428,
		429, 5, 1123, 0, 0, 429, 431, 5, 1120, 0, 0, 430, 419, 1, 0, 0, 0, 430,
		420, 1, 0, 0, 0, 430, 421, 1, 0, 0, 0, 430, 422, 1, 0, 0, 0, 430, 424,
		1, 0, 0, 0, 430, 426, 1, 0, 0, 0, 430, 428, 1, 0, 0, 0, 431, 79, 1, 0,
		0, 0, 432, 439, 5, 10, 0, 0, 433, 434, 5, 1126, 0, 0, 434, 439, 5, 1126,
		0, 0, 435, 439, 5, 122, 0, 0, 436, 437, 5, 1125, 0, 0, 437, 439, 5, 1125,
		0, 0, 438, 432, 1, 0, 0, 0, 438, 433, 1, 0, 0, 0, 438, 435, 1, 0, 0, 0,
		438, 436, 1, 0, 0, 0, 439, 81, 1, 0, 0, 0, 61, 83, 87, 94, 97, 100, 102,
		108, 111, 114, 124, 132, 139, 148, 153, 156, 159, 169, 173, 179, 184, 187,
		191, 194, 196, 203, 219, 222, 228, 235, 243, 250, 252, 255, 259, 261, 265,
		270, 277, 282, 286, 291, 294, 298, 302, 304, 309, 321, 328, 344, 349, 357,
		363, 373, 380, 382, 396, 402, 410, 413, 430, 438,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// MySqlParserInit initializes any static state used to implement MySqlParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewMySqlParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func MySqlParserInit() {
	staticData := &mysqlparserParserStaticData
	staticData.once.Do(mysqlparserParserInit)
}

// NewMySqlParser produces a new parser instance for the optional input antlr.TokenStream.
func NewMySqlParser(input antlr.TokenStream) *MySqlParser {
	MySqlParserInit()
	this := new(MySqlParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &mysqlparserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "java-escape"

	return this
}

// MySqlParser tokens.
const (
	MySqlParserEOF                               = antlr.TokenEOF
	MySqlParserSPACE                             = 1
	MySqlParserSPEC_MYSQL_COMMENT                = 2
	MySqlParserCOMMENT_INPUT                     = 3
	MySqlParserLINE_COMMENT                      = 4
	MySqlParserADD                               = 5
	MySqlParserALL                               = 6
	MySqlParserALTER                             = 7
	MySqlParserALWAYS                            = 8
	MySqlParserANALYZE                           = 9
	MySqlParserAND                               = 10
	MySqlParserARRAY                             = 11
	MySqlParserAS                                = 12
	MySqlParserASC                               = 13
	MySqlParserATTRIBUTE                         = 14
	MySqlParserBEFORE                            = 15
	MySqlParserBETWEEN                           = 16
	MySqlParserBOTH                              = 17
	MySqlParserBUCKETS                           = 18
	MySqlParserBY                                = 19
	MySqlParserCALL                              = 20
	MySqlParserCASCADE                           = 21
	MySqlParserCASE                              = 22
	MySqlParserCAST                              = 23
	MySqlParserCHANGE                            = 24
	MySqlParserCHARACTER                         = 25
	MySqlParserCHECK                             = 26
	MySqlParserCOLLATE                           = 27
	MySqlParserCOLUMN                            = 28
	MySqlParserCONDITION                         = 29
	MySqlParserCONSTRAINT                        = 30
	MySqlParserCONTINUE                          = 31
	MySqlParserCONVERT                           = 32
	MySqlParserCREATE                            = 33
	MySqlParserCROSS                             = 34
	MySqlParserCURRENT                           = 35
	MySqlParserCURRENT_ROLE                      = 36
	MySqlParserCURRENT_USER                      = 37
	MySqlParserCURSOR                            = 38
	MySqlParserDATABASE                          = 39
	MySqlParserDATABASES                         = 40
	MySqlParserDECLARE                           = 41
	MySqlParserDEFAULT                           = 42
	MySqlParserDELAYED                           = 43
	MySqlParserDELETE                            = 44
	MySqlParserDESC                              = 45
	MySqlParserDESCRIBE                          = 46
	MySqlParserDETERMINISTIC                     = 47
	MySqlParserDIAGNOSTICS                       = 48
	MySqlParserDISTINCT                          = 49
	MySqlParserDISTINCTROW                       = 50
	MySqlParserDROP                              = 51
	MySqlParserEACH                              = 52
	MySqlParserELSE                              = 53
	MySqlParserELSEIF                            = 54
	MySqlParserEMPTY                             = 55
	MySqlParserENCLOSED                          = 56
	MySqlParserESCAPED                           = 57
	MySqlParserEXCEPT                            = 58
	MySqlParserEXISTS                            = 59
	MySqlParserEXIT                              = 60
	MySqlParserEXPLAIN                           = 61
	MySqlParserFALSE                             = 62
	MySqlParserFETCH                             = 63
	MySqlParserFOR                               = 64
	MySqlParserFORCE                             = 65
	MySqlParserFOREIGN                           = 66
	MySqlParserFROM                              = 67
	MySqlParserFULLTEXT                          = 68
	MySqlParserGENERATED                         = 69
	MySqlParserGET                               = 70
	MySqlParserGRANT                             = 71
	MySqlParserGROUP                             = 72
	MySqlParserHAVING                            = 73
	MySqlParserHIGH_PRIORITY                     = 74
	MySqlParserHISTOGRAM                         = 75
	MySqlParserIF                                = 76
	MySqlParserIGNORE                            = 77
	MySqlParserIGNORED                           = 78
	MySqlParserIN                                = 79
	MySqlParserINDEX                             = 80
	MySqlParserINFILE                            = 81
	MySqlParserINNER                             = 82
	MySqlParserINOUT                             = 83
	MySqlParserINSERT                            = 84
	MySqlParserINTERVAL                          = 85
	MySqlParserINTO                              = 86
	MySqlParserIS                                = 87
	MySqlParserITERATE                           = 88
	MySqlParserJOIN                              = 89
	MySqlParserKEY                               = 90
	MySqlParserKEYS                              = 91
	MySqlParserKILL                              = 92
	MySqlParserLATERAL                           = 93
	MySqlParserLEADING                           = 94
	MySqlParserLEAVE                             = 95
	MySqlParserLEFT                              = 96
	MySqlParserLIKE                              = 97
	MySqlParserLIMIT                             = 98
	MySqlParserLINEAR                            = 99
	MySqlParserLINES                             = 100
	MySqlParserLOAD                              = 101
	MySqlParserLOCK                              = 102
	MySqlParserLOCKED                            = 103
	MySqlParserLOOP                              = 104
	MySqlParserLOW_PRIORITY                      = 105
	MySqlParserMASTER_BIND                       = 106
	MySqlParserMASTER_SSL_VERIFY_SERVER_CERT     = 107
	MySqlParserMATCH                             = 108
	MySqlParserMAXVALUE                          = 109
	MySqlParserMINVALUE                          = 110
	MySqlParserMODIFIES                          = 111
	MySqlParserNATURAL                           = 112
	MySqlParserNOT                               = 113
	MySqlParserNO_WRITE_TO_BINLOG                = 114
	MySqlParserNULL_LITERAL                      = 115
	MySqlParserNUMBER                            = 116
	MySqlParserON                                = 117
	MySqlParserOPTIMIZE                          = 118
	MySqlParserOPTION                            = 119
	MySqlParserOPTIONAL                          = 120
	MySqlParserOPTIONALLY                        = 121
	MySqlParserOR                                = 122
	MySqlParserORDER                             = 123
	MySqlParserOUT                               = 124
	MySqlParserOUTER                             = 125
	MySqlParserOUTFILE                           = 126
	MySqlParserOVER                              = 127
	MySqlParserPARTITION                         = 128
	MySqlParserPRIMARY                           = 129
	MySqlParserPROCEDURE                         = 130
	MySqlParserPURGE                             = 131
	MySqlParserRANGE                             = 132
	MySqlParserREAD                              = 133
	MySqlParserREADS                             = 134
	MySqlParserREFERENCES                        = 135
	MySqlParserREGEXP                            = 136
	MySqlParserRELEASE                           = 137
	MySqlParserRENAME                            = 138
	MySqlParserREPEAT                            = 139
	MySqlParserREPLACE                           = 140
	MySqlParserREQUIRE                           = 141
	MySqlParserRESIGNAL                          = 142
	MySqlParserRESTRICT                          = 143
	MySqlParserRETAIN                            = 144
	MySqlParserRETURN                            = 145
	MySqlParserREVOKE                            = 146
	MySqlParserRIGHT                             = 147
	MySqlParserRLIKE                             = 148
	MySqlParserSCHEMA                            = 149
	MySqlParserSCHEMAS                           = 150
	MySqlParserSELECT                            = 151
	MySqlParserSET                               = 152
	MySqlParserSEPARATOR                         = 153
	MySqlParserSHOW                              = 154
	MySqlParserSIGNAL                            = 155
	MySqlParserSKIP_                             = 156
	MySqlParserSPATIAL                           = 157
	MySqlParserSQL                               = 158
	MySqlParserSQLEXCEPTION                      = 159
	MySqlParserSQLSTATE                          = 160
	MySqlParserSQLWARNING                        = 161
	MySqlParserSQL_BIG_RESULT                    = 162
	MySqlParserSQL_CALC_FOUND_ROWS               = 163
	MySqlParserSQL_SMALL_RESULT                  = 164
	MySqlParserSSL                               = 165
	MySqlParserSTACKED                           = 166
	MySqlParserSTARTING                          = 167
	MySqlParserSTATEMENT                         = 168
	MySqlParserSTRAIGHT_JOIN                     = 169
	MySqlParserTABLE                             = 170
	MySqlParserTERMINATED                        = 171
	MySqlParserTHEN                              = 172
	MySqlParserTO                                = 173
	MySqlParserTRAILING                          = 174
	MySqlParserTRIGGER                           = 175
	MySqlParserTRUE                              = 176
	MySqlParserUNDO                              = 177
	MySqlParserUNION                             = 178
	MySqlParserUNIQUE                            = 179
	MySqlParserUNLOCK                            = 180
	MySqlParserUNSIGNED                          = 181
	MySqlParserUPDATE                            = 182
	MySqlParserUSAGE                             = 183
	MySqlParserUSE                               = 184
	MySqlParserUSING                             = 185
	MySqlParserVALUES                            = 186
	MySqlParserWHEN                              = 187
	MySqlParserWHERE                             = 188
	MySqlParserWHILE                             = 189
	MySqlParserWITH                              = 190
	MySqlParserWRITE                             = 191
	MySqlParserXOR                               = 192
	MySqlParserZEROFILL                          = 193
	MySqlParserANNS                              = 194
	MySqlParserL2                                = 195
	MySqlParserIP                                = 196
	MySqlParserTINYINT                           = 197
	MySqlParserSMALLINT                          = 198
	MySqlParserMEDIUMINT                         = 199
	MySqlParserMIDDLEINT                         = 200
	MySqlParserINT                               = 201
	MySqlParserINT1                              = 202
	MySqlParserINT2                              = 203
	MySqlParserINT3                              = 204
	MySqlParserINT4                              = 205
	MySqlParserINT8                              = 206
	MySqlParserINTEGER                           = 207
	MySqlParserBIGINT                            = 208
	MySqlParserREAL                              = 209
	MySqlParserDOUBLE                            = 210
	MySqlParserPRECISION                         = 211
	MySqlParserFLOAT                             = 212
	MySqlParserFLOAT4                            = 213
	MySqlParserFLOAT8                            = 214
	MySqlParserDECIMAL                           = 215
	MySqlParserDEC                               = 216
	MySqlParserNUMERIC                           = 217
	MySqlParserDATE                              = 218
	MySqlParserTIME                              = 219
	MySqlParserTIMESTAMP                         = 220
	MySqlParserDATETIME                          = 221
	MySqlParserYEAR                              = 222
	MySqlParserCHAR                              = 223
	MySqlParserVARCHAR                           = 224
	MySqlParserNVARCHAR                          = 225
	MySqlParserNATIONAL                          = 226
	MySqlParserBINARY                            = 227
	MySqlParserVARBINARY                         = 228
	MySqlParserTINYBLOB                          = 229
	MySqlParserBLOB                              = 230
	MySqlParserMEDIUMBLOB                        = 231
	MySqlParserLONG                              = 232
	MySqlParserLONGBLOB                          = 233
	MySqlParserTINYTEXT                          = 234
	MySqlParserTEXT                              = 235
	MySqlParserMEDIUMTEXT                        = 236
	MySqlParserLONGTEXT                          = 237
	MySqlParserENUM                              = 238
	MySqlParserVARYING                           = 239
	MySqlParserSERIAL                            = 240
	MySqlParserYEAR_MONTH                        = 241
	MySqlParserDAY_HOUR                          = 242
	MySqlParserDAY_MINUTE                        = 243
	MySqlParserDAY_SECOND                        = 244
	MySqlParserHOUR_MINUTE                       = 245
	MySqlParserHOUR_SECOND                       = 246
	MySqlParserMINUTE_SECOND                     = 247
	MySqlParserSECOND_MICROSECOND                = 248
	MySqlParserMINUTE_MICROSECOND                = 249
	MySqlParserHOUR_MICROSECOND                  = 250
	MySqlParserDAY_MICROSECOND                   = 251
	MySqlParserJSON_ARRAY                        = 252
	MySqlParserJSON_ARRAYAGG                     = 253
	MySqlParserJSON_ARRAY_APPEND                 = 254
	MySqlParserJSON_ARRAY_INSERT                 = 255
	MySqlParserJSON_CONTAINS                     = 256
	MySqlParserJSON_CONTAINS_PATH                = 257
	MySqlParserJSON_DEPTH                        = 258
	MySqlParserJSON_EXTRACT                      = 259
	MySqlParserJSON_INSERT                       = 260
	MySqlParserJSON_KEYS                         = 261
	MySqlParserJSON_LENGTH                       = 262
	MySqlParserJSON_MERGE                        = 263
	MySqlParserJSON_MERGE_PATCH                  = 264
	MySqlParserJSON_MERGE_PRESERVE               = 265
	MySqlParserJSON_OBJECT                       = 266
	MySqlParserJSON_OBJECTAGG                    = 267
	MySqlParserJSON_OVERLAPS                     = 268
	MySqlParserJSON_PRETTY                       = 269
	MySqlParserJSON_QUOTE                        = 270
	MySqlParserJSON_REMOVE                       = 271
	MySqlParserJSON_REPLACE                      = 272
	MySqlParserJSON_SCHEMA_VALID                 = 273
	MySqlParserJSON_SCHEMA_VALIDATION_REPORT     = 274
	MySqlParserJSON_SEARCH                       = 275
	MySqlParserJSON_SET                          = 276
	MySqlParserJSON_STORAGE_FREE                 = 277
	MySqlParserJSON_STORAGE_SIZE                 = 278
	MySqlParserJSON_TABLE                        = 279
	MySqlParserJSON_TYPE                         = 280
	MySqlParserJSON_UNQUOTE                      = 281
	MySqlParserJSON_VALID                        = 282
	MySqlParserJSON_VALUE                        = 283
	MySqlParserNESTED                            = 284
	MySqlParserORDINALITY                        = 285
	MySqlParserPATH                              = 286
	MySqlParserAVG                               = 287
	MySqlParserBIT_AND                           = 288
	MySqlParserBIT_OR                            = 289
	MySqlParserBIT_XOR                           = 290
	MySqlParserCOUNT                             = 291
	MySqlParserCUME_DIST                         = 292
	MySqlParserDENSE_RANK                        = 293
	MySqlParserFIRST_VALUE                       = 294
	MySqlParserGROUP_CONCAT                      = 295
	MySqlParserLAG                               = 296
	MySqlParserLAST_VALUE                        = 297
	MySqlParserLEAD                              = 298
	MySqlParserMAX                               = 299
	MySqlParserMIN                               = 300
	MySqlParserNTILE                             = 301
	MySqlParserNTH_VALUE                         = 302
	MySqlParserPERCENT_RANK                      = 303
	MySqlParserRANK                              = 304
	MySqlParserROW_NUMBER                        = 305
	MySqlParserSTD                               = 306
	MySqlParserSTDDEV                            = 307
	MySqlParserSTDDEV_POP                        = 308
	MySqlParserSTDDEV_SAMP                       = 309
	MySqlParserSUM                               = 310
	MySqlParserVAR_POP                           = 311
	MySqlParserVAR_SAMP                          = 312
	MySqlParserVARIANCE                          = 313
	MySqlParserCURRENT_DATE                      = 314
	MySqlParserCURRENT_TIME                      = 315
	MySqlParserCURRENT_TIMESTAMP                 = 316
	MySqlParserLOCALTIME                         = 317
	MySqlParserCURDATE                           = 318
	MySqlParserCURTIME                           = 319
	MySqlParserDATE_ADD                          = 320
	MySqlParserDATE_SUB                          = 321
	MySqlParserEXTRACT                           = 322
	MySqlParserLOCALTIMESTAMP                    = 323
	MySqlParserNOW                               = 324
	MySqlParserPOSITION                          = 325
	MySqlParserSUBSTR                            = 326
	MySqlParserSUBSTRING                         = 327
	MySqlParserSYSDATE                           = 328
	MySqlParserTRIM                              = 329
	MySqlParserUTC_DATE                          = 330
	MySqlParserUTC_TIME                          = 331
	MySqlParserUTC_TIMESTAMP                     = 332
	MySqlParserACCOUNT                           = 333
	MySqlParserACTION                            = 334
	MySqlParserAFTER                             = 335
	MySqlParserAGGREGATE                         = 336
	MySqlParserALGORITHM                         = 337
	MySqlParserANY                               = 338
	MySqlParserAT                                = 339
	MySqlParserAUTHORS                           = 340
	MySqlParserAUTOCOMMIT                        = 341
	MySqlParserAUTOEXTEND_SIZE                   = 342
	MySqlParserAUTO_INCREMENT                    = 343
	MySqlParserAVG_ROW_LENGTH                    = 344
	MySqlParserBEGIN                             = 345
	MySqlParserBINLOG                            = 346
	MySqlParserBIT                               = 347
	MySqlParserBLOCK                             = 348
	MySqlParserBOOL                              = 349
	MySqlParserBOOLEAN                           = 350
	MySqlParserBTREE                             = 351
	MySqlParserCACHE                             = 352
	MySqlParserCASCADED                          = 353
	MySqlParserCHAIN                             = 354
	MySqlParserCHANGED                           = 355
	MySqlParserCHANNEL                           = 356
	MySqlParserCHECKSUM                          = 357
	MySqlParserPAGE_CHECKSUM                     = 358
	MySqlParserCIPHER                            = 359
	MySqlParserCLASS_ORIGIN                      = 360
	MySqlParserCLIENT                            = 361
	MySqlParserCLOSE                             = 362
	MySqlParserCLUSTERING                        = 363
	MySqlParserCOALESCE                          = 364
	MySqlParserCODE                              = 365
	MySqlParserCOLUMNS                           = 366
	MySqlParserCOLUMN_FORMAT                     = 367
	MySqlParserCOLUMN_NAME                       = 368
	MySqlParserCOMMENT                           = 369
	MySqlParserCOMMIT                            = 370
	MySqlParserCOMPACT                           = 371
	MySqlParserCOMPLETION                        = 372
	MySqlParserCOMPRESSED                        = 373
	MySqlParserCOMPRESSION                       = 374
	MySqlParserCONCURRENT                        = 375
	MySqlParserCONNECT                           = 376
	MySqlParserCONNECTION                        = 377
	MySqlParserCONSISTENT                        = 378
	MySqlParserCONSTRAINT_CATALOG                = 379
	MySqlParserCONSTRAINT_SCHEMA                 = 380
	MySqlParserCONSTRAINT_NAME                   = 381
	MySqlParserCONTAINS                          = 382
	MySqlParserCONTEXT                           = 383
	MySqlParserCONTRIBUTORS                      = 384
	MySqlParserCOPY                              = 385
	MySqlParserCPU                               = 386
	MySqlParserCYCLE                             = 387
	MySqlParserCURSOR_NAME                       = 388
	MySqlParserDATA                              = 389
	MySqlParserDATAFILE                          = 390
	MySqlParserDEALLOCATE                        = 391
	MySqlParserDEFAULT_AUTH                      = 392
	MySqlParserDEFINER                           = 393
	MySqlParserDELAY_KEY_WRITE                   = 394
	MySqlParserDES_KEY_FILE                      = 395
	MySqlParserDIRECTORY                         = 396
	MySqlParserDISABLE                           = 397
	MySqlParserDISCARD                           = 398
	MySqlParserDISK                              = 399
	MySqlParserDO                                = 400
	MySqlParserDUMPFILE                          = 401
	MySqlParserDUPLICATE                         = 402
	MySqlParserDYNAMIC                           = 403
	MySqlParserENABLE                            = 404
	MySqlParserENCRYPTED                         = 405
	MySqlParserENCRYPTION                        = 406
	MySqlParserENCRYPTION_KEY_ID                 = 407
	MySqlParserEND                               = 408
	MySqlParserENDS                              = 409
	MySqlParserENGINE                            = 410
	MySqlParserENGINES                           = 411
	MySqlParserERROR                             = 412
	MySqlParserERRORS                            = 413
	MySqlParserESCAPE                            = 414
	MySqlParserEVEN                              = 415
	MySqlParserEVENT                             = 416
	MySqlParserEVENTS                            = 417
	MySqlParserEVERY                             = 418
	MySqlParserEXCHANGE                          = 419
	MySqlParserEXCLUSIVE                         = 420
	MySqlParserEXPIRE                            = 421
	MySqlParserEXPORT                            = 422
	MySqlParserEXTENDED                          = 423
	MySqlParserEXTENT_SIZE                       = 424
	MySqlParserFAILED_LOGIN_ATTEMPTS             = 425
	MySqlParserFAST                              = 426
	MySqlParserFAULTS                            = 427
	MySqlParserFIELDS                            = 428
	MySqlParserFILE_BLOCK_SIZE                   = 429
	MySqlParserFILTER                            = 430
	MySqlParserFIRST                             = 431
	MySqlParserFIXED                             = 432
	MySqlParserFLUSH                             = 433
	MySqlParserFOLLOWING                         = 434
	MySqlParserFOLLOWS                           = 435
	MySqlParserFOUND                             = 436
	MySqlParserFULL                              = 437
	MySqlParserFUNCTION                          = 438
	MySqlParserGENERAL                           = 439
	MySqlParserGLOBAL                            = 440
	MySqlParserGRANTS                            = 441
	MySqlParserGROUP_REPLICATION                 = 442
	MySqlParserHANDLER                           = 443
	MySqlParserHASH                              = 444
	MySqlParserHELP                              = 445
	MySqlParserHISTORY                           = 446
	MySqlParserHOST                              = 447
	MySqlParserHOSTS                             = 448
	MySqlParserIDENTIFIED                        = 449
	MySqlParserIGNORE_SERVER_IDS                 = 450
	MySqlParserIMPORT                            = 451
	MySqlParserINCREMENT                         = 452
	MySqlParserINDEXES                           = 453
	MySqlParserINITIAL_SIZE                      = 454
	MySqlParserINPLACE                           = 455
	MySqlParserINSERT_METHOD                     = 456
	MySqlParserINSTALL                           = 457
	MySqlParserINSTANCE                          = 458
	MySqlParserINSTANT                           = 459
	MySqlParserINVISIBLE                         = 460
	MySqlParserINVOKER                           = 461
	MySqlParserIO                                = 462
	MySqlParserIO_THREAD                         = 463
	MySqlParserIPC                               = 464
	MySqlParserISOLATION                         = 465
	MySqlParserISSUER                            = 466
	MySqlParserJSON                              = 467
	MySqlParserKEY_BLOCK_SIZE                    = 468
	MySqlParserLANGUAGE                          = 469
	MySqlParserLAST                              = 470
	MySqlParserLEAVES                            = 471
	MySqlParserLESS                              = 472
	MySqlParserLEVEL                             = 473
	MySqlParserLIST                              = 474
	MySqlParserLOCAL                             = 475
	MySqlParserLOGFILE                           = 476
	MySqlParserLOGS                              = 477
	MySqlParserMASTER                            = 478
	MySqlParserMASTER_AUTO_POSITION              = 479
	MySqlParserMASTER_CONNECT_RETRY              = 480
	MySqlParserMASTER_DELAY                      = 481
	MySqlParserMASTER_HEARTBEAT_PERIOD           = 482
	MySqlParserMASTER_HOST                       = 483
	MySqlParserMASTER_LOG_FILE                   = 484
	MySqlParserMASTER_LOG_POS                    = 485
	MySqlParserMASTER_PASSWORD                   = 486
	MySqlParserMASTER_PORT                       = 487
	MySqlParserMASTER_RETRY_COUNT                = 488
	MySqlParserMASTER_SSL                        = 489
	MySqlParserMASTER_SSL_CA                     = 490
	MySqlParserMASTER_SSL_CAPATH                 = 491
	MySqlParserMASTER_SSL_CERT                   = 492
	MySqlParserMASTER_SSL_CIPHER                 = 493
	MySqlParserMASTER_SSL_CRL                    = 494
	MySqlParserMASTER_SSL_CRLPATH                = 495
	MySqlParserMASTER_SSL_KEY                    = 496
	MySqlParserMASTER_TLS_VERSION                = 497
	MySqlParserMASTER_USER                       = 498
	MySqlParserMAX_CONNECTIONS_PER_HOUR          = 499
	MySqlParserMAX_QUERIES_PER_HOUR              = 500
	MySqlParserMAX_ROWS                          = 501
	MySqlParserMAX_SIZE                          = 502
	MySqlParserMAX_UPDATES_PER_HOUR              = 503
	MySqlParserMAX_USER_CONNECTIONS              = 504
	MySqlParserMEDIUM                            = 505
	MySqlParserMEMBER                            = 506
	MySqlParserMERGE                             = 507
	MySqlParserMESSAGE_TEXT                      = 508
	MySqlParserMID                               = 509
	MySqlParserMIGRATE                           = 510
	MySqlParserMIN_ROWS                          = 511
	MySqlParserMODE                              = 512
	MySqlParserMODIFY                            = 513
	MySqlParserMUTEX                             = 514
	MySqlParserMYSQL                             = 515
	MySqlParserMYSQL_ERRNO                       = 516
	MySqlParserNAME                              = 517
	MySqlParserNAMES                             = 518
	MySqlParserNCHAR                             = 519
	MySqlParserNEVER                             = 520
	MySqlParserNEXT                              = 521
	MySqlParserNO                                = 522
	MySqlParserNOCACHE                           = 523
	MySqlParserNOCOPY                            = 524
	MySqlParserNOCYCLE                           = 525
	MySqlParserNOMAXVALUE                        = 526
	MySqlParserNOMINVALUE                        = 527
	MySqlParserNOWAIT                            = 528
	MySqlParserNODEGROUP                         = 529
	MySqlParserNONE                              = 530
	MySqlParserODBC                              = 531
	MySqlParserOFFLINE                           = 532
	MySqlParserOFFSET                            = 533
	MySqlParserOF                                = 534
	MySqlParserOJ                                = 535
	MySqlParserOLD_PASSWORD                      = 536
	MySqlParserONE                               = 537
	MySqlParserONLINE                            = 538
	MySqlParserONLY                              = 539
	MySqlParserOPEN                              = 540
	MySqlParserOPTIMIZER_COSTS                   = 541
	MySqlParserOPTIONS                           = 542
	MySqlParserOWNER                             = 543
	MySqlParserPACK_KEYS                         = 544
	MySqlParserPAGE                              = 545
	MySqlParserPAGE_COMPRESSED                   = 546
	MySqlParserPAGE_COMPRESSION_LEVEL            = 547
	MySqlParserPARSER                            = 548
	MySqlParserPARTIAL                           = 549
	MySqlParserPARTITIONING                      = 550
	MySqlParserPARTITIONS                        = 551
	MySqlParserPASSWORD                          = 552
	MySqlParserPASSWORD_LOCK_TIME                = 553
	MySqlParserPHASE                             = 554
	MySqlParserPLUGIN                            = 555
	MySqlParserPLUGIN_DIR                        = 556
	MySqlParserPLUGINS                           = 557
	MySqlParserPORT                              = 558
	MySqlParserPRECEDES                          = 559
	MySqlParserPRECEDING                         = 560
	MySqlParserPREPARE                           = 561
	MySqlParserPRESERVE                          = 562
	MySqlParserPREV                              = 563
	MySqlParserPROCESSLIST                       = 564
	MySqlParserPROFILE                           = 565
	MySqlParserPROFILES                          = 566
	MySqlParserPROXY                             = 567
	MySqlParserQUERY                             = 568
	MySqlParserQUICK                             = 569
	MySqlParserREBUILD                           = 570
	MySqlParserRECOVER                           = 571
	MySqlParserRECURSIVE                         = 572
	MySqlParserREDO_BUFFER_SIZE                  = 573
	MySqlParserREDUNDANT                         = 574
	MySqlParserRELAY                             = 575
	MySqlParserRELAY_LOG_FILE                    = 576
	MySqlParserRELAY_LOG_POS                     = 577
	MySqlParserRELAYLOG                          = 578
	MySqlParserREMOVE                            = 579
	MySqlParserREORGANIZE                        = 580
	MySqlParserREPAIR                            = 581
	MySqlParserREPLICATE_DO_DB                   = 582
	MySqlParserREPLICATE_DO_TABLE                = 583
	MySqlParserREPLICATE_IGNORE_DB               = 584
	MySqlParserREPLICATE_IGNORE_TABLE            = 585
	MySqlParserREPLICATE_REWRITE_DB              = 586
	MySqlParserREPLICATE_WILD_DO_TABLE           = 587
	MySqlParserREPLICATE_WILD_IGNORE_TABLE       = 588
	MySqlParserREPLICATION                       = 589
	MySqlParserRESET                             = 590
	MySqlParserRESTART                           = 591
	MySqlParserRESUME                            = 592
	MySqlParserRETURNED_SQLSTATE                 = 593
	MySqlParserRETURNING                         = 594
	MySqlParserRETURNS                           = 595
	MySqlParserREUSE                             = 596
	MySqlParserROLE                              = 597
	MySqlParserROLLBACK                          = 598
	MySqlParserROLLUP                            = 599
	MySqlParserROTATE                            = 600
	MySqlParserROW                               = 601
	MySqlParserROWS                              = 602
	MySqlParserROW_FORMAT                        = 603
	MySqlParserRTREE                             = 604
	MySqlParserSAVEPOINT                         = 605
	MySqlParserSCHEDULE                          = 606
	MySqlParserSECURITY                          = 607
	MySqlParserSEQUENCE                          = 608
	MySqlParserSERVER                            = 609
	MySqlParserSESSION                           = 610
	MySqlParserSHARE                             = 611
	MySqlParserSHARED                            = 612
	MySqlParserSIGNED                            = 613
	MySqlParserSIMPLE                            = 614
	MySqlParserSLAVE                             = 615
	MySqlParserSLOW                              = 616
	MySqlParserSNAPSHOT                          = 617
	MySqlParserSOCKET                            = 618
	MySqlParserSOME                              = 619
	MySqlParserSONAME                            = 620
	MySqlParserSOUNDS                            = 621
	MySqlParserSOURCE                            = 622
	MySqlParserSQL_AFTER_GTIDS                   = 623
	MySqlParserSQL_AFTER_MTS_GAPS                = 624
	MySqlParserSQL_BEFORE_GTIDS                  = 625
	MySqlParserSQL_BUFFER_RESULT                 = 626
	MySqlParserSQL_CACHE                         = 627
	MySqlParserSQL_NO_CACHE                      = 628
	MySqlParserSQL_THREAD                        = 629
	MySqlParserSTART                             = 630
	MySqlParserSTARTS                            = 631
	MySqlParserSTATS_AUTO_RECALC                 = 632
	MySqlParserSTATS_PERSISTENT                  = 633
	MySqlParserSTATS_SAMPLE_PAGES                = 634
	MySqlParserSTATUS                            = 635
	MySqlParserSTOP                              = 636
	MySqlParserSTORAGE                           = 637
	MySqlParserSTORED                            = 638
	MySqlParserSTRING                            = 639
	MySqlParserSUBCLASS_ORIGIN                   = 640
	MySqlParserSUBJECT                           = 641
	MySqlParserSUBPARTITION                      = 642
	MySqlParserSUBPARTITIONS                     = 643
	MySqlParserSUSPEND                           = 644
	MySqlParserSWAPS                             = 645
	MySqlParserSWITCHES                          = 646
	MySqlParserTABLE_NAME                        = 647
	MySqlParserTABLESPACE                        = 648
	MySqlParserTABLE_TYPE                        = 649
	MySqlParserTEMPORARY                         = 650
	MySqlParserTEMPTABLE                         = 651
	MySqlParserTHAN                              = 652
	MySqlParserTRADITIONAL                       = 653
	MySqlParserTRANSACTION                       = 654
	MySqlParserTRANSACTIONAL                     = 655
	MySqlParserTRIGGERS                          = 656
	MySqlParserTRUNCATE                          = 657
	MySqlParserUNBOUNDED                         = 658
	MySqlParserUNDEFINED                         = 659
	MySqlParserUNDOFILE                          = 660
	MySqlParserUNDO_BUFFER_SIZE                  = 661
	MySqlParserUNINSTALL                         = 662
	MySqlParserUNKNOWN                           = 663
	MySqlParserUNTIL                             = 664
	MySqlParserUPGRADE                           = 665
	MySqlParserUSER                              = 666
	MySqlParserUSE_FRM                           = 667
	MySqlParserUSER_RESOURCES                    = 668
	MySqlParserVALIDATION                        = 669
	MySqlParserVALUE                             = 670
	MySqlParserVARIABLES                         = 671
	MySqlParserVIEW                              = 672
	MySqlParserVIRTUAL                           = 673
	MySqlParserVISIBLE                           = 674
	MySqlParserWAIT                              = 675
	MySqlParserWARNINGS                          = 676
	MySqlParserWINDOW                            = 677
	MySqlParserWITHOUT                           = 678
	MySqlParserWORK                              = 679
	MySqlParserWRAPPER                           = 680
	MySqlParserX509                              = 681
	MySqlParserXA                                = 682
	MySqlParserXML                               = 683
	MySqlParserYES                               = 684
	MySqlParserEUR                               = 685
	MySqlParserUSA                               = 686
	MySqlParserJIS                               = 687
	MySqlParserISO                               = 688
	MySqlParserINTERNAL                          = 689
	MySqlParserQUARTER                           = 690
	MySqlParserMONTH                             = 691
	MySqlParserDAY                               = 692
	MySqlParserHOUR                              = 693
	MySqlParserMINUTE                            = 694
	MySqlParserWEEK                              = 695
	MySqlParserSECOND                            = 696
	MySqlParserMICROSECOND                       = 697
	MySqlParserADMIN                             = 698
	MySqlParserAPPLICATION_PASSWORD_ADMIN        = 699
	MySqlParserAUDIT_ADMIN                       = 700
	MySqlParserBACKUP_ADMIN                      = 701
	MySqlParserBINLOG_ADMIN                      = 702
	MySqlParserBINLOG_ENCRYPTION_ADMIN           = 703
	MySqlParserCLONE_ADMIN                       = 704
	MySqlParserCONNECTION_ADMIN                  = 705
	MySqlParserENCRYPTION_KEY_ADMIN              = 706
	MySqlParserEXECUTE                           = 707
	MySqlParserFILE                              = 708
	MySqlParserFIREWALL_ADMIN                    = 709
	MySqlParserFIREWALL_USER                     = 710
	MySqlParserFLUSH_OPTIMIZER_COSTS             = 711
	MySqlParserFLUSH_STATUS                      = 712
	MySqlParserFLUSH_TABLES                      = 713
	MySqlParserFLUSH_USER_RESOURCES              = 714
	MySqlParserGROUP_REPLICATION_ADMIN           = 715
	MySqlParserINNODB_REDO_LOG_ARCHIVE           = 716
	MySqlParserINNODB_REDO_LOG_ENABLE            = 717
	MySqlParserINVOKE                            = 718
	MySqlParserLAMBDA                            = 719
	MySqlParserNDB_STORED_USER                   = 720
	MySqlParserPASSWORDLESS_USER_ADMIN           = 721
	MySqlParserPERSIST_RO_VARIABLES_ADMIN        = 722
	MySqlParserPRIVILEGES                        = 723
	MySqlParserPROCESS                           = 724
	MySqlParserRELOAD                            = 725
	MySqlParserREPLICATION_APPLIER               = 726
	MySqlParserREPLICATION_SLAVE_ADMIN           = 727
	MySqlParserRESOURCE_GROUP_ADMIN              = 728
	MySqlParserRESOURCE_GROUP_USER               = 729
	MySqlParserROLE_ADMIN                        = 730
	MySqlParserROUTINE                           = 731
	MySqlParserS3                                = 732
	MySqlParserSERVICE_CONNECTION_ADMIN          = 733
	MySqlParserSESSION_VARIABLES_ADMIN           = 734
	MySqlParserSET_USER_ID                       = 735
	MySqlParserSHOW_ROUTINE                      = 736
	MySqlParserSHUTDOWN                          = 737
	MySqlParserSUPER                             = 738
	MySqlParserSYSTEM_VARIABLES_ADMIN            = 739
	MySqlParserTABLES                            = 740
	MySqlParserTABLE_ENCRYPTION_ADMIN            = 741
	MySqlParserVERSION_TOKEN_ADMIN               = 742
	MySqlParserXA_RECOVER_ADMIN                  = 743
	MySqlParserARMSCII8                          = 744
	MySqlParserASCII                             = 745
	MySqlParserBIG5                              = 746
	MySqlParserCP1250                            = 747
	MySqlParserCP1251                            = 748
	MySqlParserCP1256                            = 749
	MySqlParserCP1257                            = 750
	MySqlParserCP850                             = 751
	MySqlParserCP852                             = 752
	MySqlParserCP866                             = 753
	MySqlParserCP932                             = 754
	MySqlParserDEC8                              = 755
	MySqlParserEUCJPMS                           = 756
	MySqlParserEUCKR                             = 757
	MySqlParserGB18030                           = 758
	MySqlParserGB2312                            = 759
	MySqlParserGBK                               = 760
	MySqlParserGEOSTD8                           = 761
	MySqlParserGREEK                             = 762
	MySqlParserHEBREW                            = 763
	MySqlParserHP8                               = 764
	MySqlParserKEYBCS2                           = 765
	MySqlParserKOI8R                             = 766
	MySqlParserKOI8U                             = 767
	MySqlParserLATIN1                            = 768
	MySqlParserLATIN2                            = 769
	MySqlParserLATIN5                            = 770
	MySqlParserLATIN7                            = 771
	MySqlParserMACCE                             = 772
	MySqlParserMACROMAN                          = 773
	MySqlParserSJIS                              = 774
	MySqlParserSWE7                              = 775
	MySqlParserTIS620                            = 776
	MySqlParserUCS2                              = 777
	MySqlParserUJIS                              = 778
	MySqlParserUTF16                             = 779
	MySqlParserUTF16LE                           = 780
	MySqlParserUTF32                             = 781
	MySqlParserUTF8                              = 782
	MySqlParserUTF8MB3                           = 783
	MySqlParserUTF8MB4                           = 784
	MySqlParserARCHIVE                           = 785
	MySqlParserBLACKHOLE                         = 786
	MySqlParserCSV                               = 787
	MySqlParserFEDERATED                         = 788
	MySqlParserINNODB                            = 789
	MySqlParserMEMORY                            = 790
	MySqlParserMRG_MYISAM                        = 791
	MySqlParserMYISAM                            = 792
	MySqlParserNDB                               = 793
	MySqlParserNDBCLUSTER                        = 794
	MySqlParserPERFORMANCE_SCHEMA                = 795
	MySqlParserTOKUDB                            = 796
	MySqlParserREPEATABLE                        = 797
	MySqlParserCOMMITTED                         = 798
	MySqlParserUNCOMMITTED                       = 799
	MySqlParserSERIALIZABLE                      = 800
	MySqlParserGEOMETRYCOLLECTION                = 801
	MySqlParserGEOMCOLLECTION                    = 802
	MySqlParserGEOMETRY                          = 803
	MySqlParserLINESTRING                        = 804
	MySqlParserMULTILINESTRING                   = 805
	MySqlParserMULTIPOINT                        = 806
	MySqlParserMULTIPOLYGON                      = 807
	MySqlParserPOINT                             = 808
	MySqlParserPOLYGON                           = 809
	MySqlParserABS                               = 810
	MySqlParserACOS                              = 811
	MySqlParserADDDATE                           = 812
	MySqlParserADDTIME                           = 813
	MySqlParserAES_DECRYPT                       = 814
	MySqlParserAES_ENCRYPT                       = 815
	MySqlParserAREA                              = 816
	MySqlParserASBINARY                          = 817
	MySqlParserASIN                              = 818
	MySqlParserASTEXT                            = 819
	MySqlParserASWKB                             = 820
	MySqlParserASWKT                             = 821
	MySqlParserASYMMETRIC_DECRYPT                = 822
	MySqlParserASYMMETRIC_DERIVE                 = 823
	MySqlParserASYMMETRIC_ENCRYPT                = 824
	MySqlParserASYMMETRIC_SIGN                   = 825
	MySqlParserASYMMETRIC_VERIFY                 = 826
	MySqlParserATAN                              = 827
	MySqlParserATAN2                             = 828
	MySqlParserBENCHMARK                         = 829
	MySqlParserBIN                               = 830
	MySqlParserBIT_COUNT                         = 831
	MySqlParserBIT_LENGTH                        = 832
	MySqlParserBUFFER                            = 833
	MySqlParserCATALOG_NAME                      = 834
	MySqlParserCEIL                              = 835
	MySqlParserCEILING                           = 836
	MySqlParserCENTROID                          = 837
	MySqlParserCHARACTER_LENGTH                  = 838
	MySqlParserCHARSET                           = 839
	MySqlParserCHAR_LENGTH                       = 840
	MySqlParserCOERCIBILITY                      = 841
	MySqlParserCOLLATION                         = 842
	MySqlParserCOMPRESS                          = 843
	MySqlParserCONCAT                            = 844
	MySqlParserCONCAT_WS                         = 845
	MySqlParserCONNECTION_ID                     = 846
	MySqlParserCONV                              = 847
	MySqlParserCONVERT_TZ                        = 848
	MySqlParserCOS                               = 849
	MySqlParserCOT                               = 850
	MySqlParserCRC32                             = 851
	MySqlParserCREATE_ASYMMETRIC_PRIV_KEY        = 852
	MySqlParserCREATE_ASYMMETRIC_PUB_KEY         = 853
	MySqlParserCREATE_DH_PARAMETERS              = 854
	MySqlParserCREATE_DIGEST                     = 855
	MySqlParserCROSSES                           = 856
	MySqlParserDATEDIFF                          = 857
	MySqlParserDATE_FORMAT                       = 858
	MySqlParserDAYNAME                           = 859
	MySqlParserDAYOFMONTH                        = 860
	MySqlParserDAYOFWEEK                         = 861
	MySqlParserDAYOFYEAR                         = 862
	MySqlParserDECODE                            = 863
	MySqlParserDEGREES                           = 864
	MySqlParserDES_DECRYPT                       = 865
	MySqlParserDES_ENCRYPT                       = 866
	MySqlParserDIMENSION                         = 867
	MySqlParserDISJOINT                          = 868
	MySqlParserELT                               = 869
	MySqlParserENCODE                            = 870
	MySqlParserENCRYPT                           = 871
	MySqlParserENDPOINT                          = 872
	MySqlParserENGINE_ATTRIBUTE                  = 873
	MySqlParserENVELOPE                          = 874
	MySqlParserEQUALS                            = 875
	MySqlParserEXP                               = 876
	MySqlParserEXPORT_SET                        = 877
	MySqlParserEXTERIORRING                      = 878
	MySqlParserEXTRACTVALUE                      = 879
	MySqlParserFIELD                             = 880
	MySqlParserFIND_IN_SET                       = 881
	MySqlParserFLOOR                             = 882
	MySqlParserFORMAT                            = 883
	MySqlParserFOUND_ROWS                        = 884
	MySqlParserFROM_BASE64                       = 885
	MySqlParserFROM_DAYS                         = 886
	MySqlParserFROM_UNIXTIME                     = 887
	MySqlParserGEOMCOLLFROMTEXT                  = 888
	MySqlParserGEOMCOLLFROMWKB                   = 889
	MySqlParserGEOMETRYCOLLECTIONFROMTEXT        = 890
	MySqlParserGEOMETRYCOLLECTIONFROMWKB         = 891
	MySqlParserGEOMETRYFROMTEXT                  = 892
	MySqlParserGEOMETRYFROMWKB                   = 893
	MySqlParserGEOMETRYN                         = 894
	MySqlParserGEOMETRYTYPE                      = 895
	MySqlParserGEOMFROMTEXT                      = 896
	MySqlParserGEOMFROMWKB                       = 897
	MySqlParserGET_FORMAT                        = 898
	MySqlParserGET_LOCK                          = 899
	MySqlParserGLENGTH                           = 900
	MySqlParserGREATEST                          = 901
	MySqlParserGTID_SUBSET                       = 902
	MySqlParserGTID_SUBTRACT                     = 903
	MySqlParserHEX                               = 904
	MySqlParserIFNULL                            = 905
	MySqlParserINET6_ATON                        = 906
	MySqlParserINET6_NTOA                        = 907
	MySqlParserINET_ATON                         = 908
	MySqlParserINET_NTOA                         = 909
	MySqlParserINSTR                             = 910
	MySqlParserINTERIORRINGN                     = 911
	MySqlParserINTERSECTS                        = 912
	MySqlParserISCLOSED                          = 913
	MySqlParserISEMPTY                           = 914
	MySqlParserISNULL                            = 915
	MySqlParserISSIMPLE                          = 916
	MySqlParserIS_FREE_LOCK                      = 917
	MySqlParserIS_IPV4                           = 918
	MySqlParserIS_IPV4_COMPAT                    = 919
	MySqlParserIS_IPV4_MAPPED                    = 920
	MySqlParserIS_IPV6                           = 921
	MySqlParserIS_USED_LOCK                      = 922
	MySqlParserLAST_INSERT_ID                    = 923
	MySqlParserLCASE                             = 924
	MySqlParserLEAST                             = 925
	MySqlParserLENGTH                            = 926
	MySqlParserLINEFROMTEXT                      = 927
	MySqlParserLINEFROMWKB                       = 928
	MySqlParserLINESTRINGFROMTEXT                = 929
	MySqlParserLINESTRINGFROMWKB                 = 930
	MySqlParserLN                                = 931
	MySqlParserLOAD_FILE                         = 932
	MySqlParserLOCATE                            = 933
	MySqlParserLOG                               = 934
	MySqlParserLOG10                             = 935
	MySqlParserLOG2                              = 936
	MySqlParserLOWER                             = 937
	MySqlParserLPAD                              = 938
	MySqlParserLTRIM                             = 939
	MySqlParserMAKEDATE                          = 940
	MySqlParserMAKETIME                          = 941
	MySqlParserMAKE_SET                          = 942
	MySqlParserMASTER_POS_WAIT                   = 943
	MySqlParserMBRCONTAINS                       = 944
	MySqlParserMBRDISJOINT                       = 945
	MySqlParserMBREQUAL                          = 946
	MySqlParserMBRINTERSECTS                     = 947
	MySqlParserMBROVERLAPS                       = 948
	MySqlParserMBRTOUCHES                        = 949
	MySqlParserMBRWITHIN                         = 950
	MySqlParserMD5                               = 951
	MySqlParserMLINEFROMTEXT                     = 952
	MySqlParserMLINEFROMWKB                      = 953
	MySqlParserMONTHNAME                         = 954
	MySqlParserMPOINTFROMTEXT                    = 955
	MySqlParserMPOINTFROMWKB                     = 956
	MySqlParserMPOLYFROMTEXT                     = 957
	MySqlParserMPOLYFROMWKB                      = 958
	MySqlParserMULTILINESTRINGFROMTEXT           = 959
	MySqlParserMULTILINESTRINGFROMWKB            = 960
	MySqlParserMULTIPOINTFROMTEXT                = 961
	MySqlParserMULTIPOINTFROMWKB                 = 962
	MySqlParserMULTIPOLYGONFROMTEXT              = 963
	MySqlParserMULTIPOLYGONFROMWKB               = 964
	MySqlParserNAME_CONST                        = 965
	MySqlParserNULLIF                            = 966
	MySqlParserNUMGEOMETRIES                     = 967
	MySqlParserNUMINTERIORRINGS                  = 968
	MySqlParserNUMPOINTS                         = 969
	MySqlParserOCT                               = 970
	MySqlParserOCTET_LENGTH                      = 971
	MySqlParserORD                               = 972
	MySqlParserOVERLAPS                          = 973
	MySqlParserPERIOD_ADD                        = 974
	MySqlParserPERIOD_DIFF                       = 975
	MySqlParserPI                                = 976
	MySqlParserPOINTFROMTEXT                     = 977
	MySqlParserPOINTFROMWKB                      = 978
	MySqlParserPOINTN                            = 979
	MySqlParserPOLYFROMTEXT                      = 980
	MySqlParserPOLYFROMWKB                       = 981
	MySqlParserPOLYGONFROMTEXT                   = 982
	MySqlParserPOLYGONFROMWKB                    = 983
	MySqlParserPOW                               = 984
	MySqlParserPOWER                             = 985
	MySqlParserQUOTE                             = 986
	MySqlParserRADIANS                           = 987
	MySqlParserRAND                              = 988
	MySqlParserRANDOM_BYTES                      = 989
	MySqlParserRELEASE_LOCK                      = 990
	MySqlParserREVERSE                           = 991
	MySqlParserROUND                             = 992
	MySqlParserROW_COUNT                         = 993
	MySqlParserRPAD                              = 994
	MySqlParserRTRIM                             = 995
	MySqlParserSEC_TO_TIME                       = 996
	MySqlParserSECONDARY_ENGINE_ATTRIBUTE        = 997
	MySqlParserSESSION_USER                      = 998
	MySqlParserSHA                               = 999
	MySqlParserSHA1                              = 1000
	MySqlParserSHA2                              = 1001
	MySqlParserSCHEMA_NAME                       = 1002
	MySqlParserSIGN                              = 1003
	MySqlParserSIN                               = 1004
	MySqlParserSLEEP                             = 1005
	MySqlParserSOUNDEX                           = 1006
	MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS       = 1007
	MySqlParserSQRT                              = 1008
	MySqlParserSRID                              = 1009
	MySqlParserSTARTPOINT                        = 1010
	MySqlParserSTRCMP                            = 1011
	MySqlParserSTR_TO_DATE                       = 1012
	MySqlParserST_AREA                           = 1013
	MySqlParserST_ASBINARY                       = 1014
	MySqlParserST_ASTEXT                         = 1015
	MySqlParserST_ASWKB                          = 1016
	MySqlParserST_ASWKT                          = 1017
	MySqlParserST_BUFFER                         = 1018
	MySqlParserST_CENTROID                       = 1019
	MySqlParserST_CONTAINS                       = 1020
	MySqlParserST_CROSSES                        = 1021
	MySqlParserST_DIFFERENCE                     = 1022
	MySqlParserST_DIMENSION                      = 1023
	MySqlParserST_DISJOINT                       = 1024
	MySqlParserST_DISTANCE                       = 1025
	MySqlParserST_ENDPOINT                       = 1026
	MySqlParserST_ENVELOPE                       = 1027
	MySqlParserST_EQUALS                         = 1028
	MySqlParserST_EXTERIORRING                   = 1029
	MySqlParserST_GEOMCOLLFROMTEXT               = 1030
	MySqlParserST_GEOMCOLLFROMTXT                = 1031
	MySqlParserST_GEOMCOLLFROMWKB                = 1032
	MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT     = 1033
	MySqlParserST_GEOMETRYCOLLECTIONFROMWKB      = 1034
	MySqlParserST_GEOMETRYFROMTEXT               = 1035
	MySqlParserST_GEOMETRYFROMWKB                = 1036
	MySqlParserST_GEOMETRYN                      = 1037
	MySqlParserST_GEOMETRYTYPE                   = 1038
	MySqlParserST_GEOMFROMTEXT                   = 1039
	MySqlParserST_GEOMFROMWKB                    = 1040
	MySqlParserST_INTERIORRINGN                  = 1041
	MySqlParserST_INTERSECTION                   = 1042
	MySqlParserST_INTERSECTS                     = 1043
	MySqlParserST_ISCLOSED                       = 1044
	MySqlParserST_ISEMPTY                        = 1045
	MySqlParserST_ISSIMPLE                       = 1046
	MySqlParserST_LINEFROMTEXT                   = 1047
	MySqlParserST_LINEFROMWKB                    = 1048
	MySqlParserST_LINESTRINGFROMTEXT             = 1049
	MySqlParserST_LINESTRINGFROMWKB              = 1050
	MySqlParserST_NUMGEOMETRIES                  = 1051
	MySqlParserST_NUMINTERIORRING                = 1052
	MySqlParserST_NUMINTERIORRINGS               = 1053
	MySqlParserST_NUMPOINTS                      = 1054
	MySqlParserST_OVERLAPS                       = 1055
	MySqlParserST_POINTFROMTEXT                  = 1056
	MySqlParserST_POINTFROMWKB                   = 1057
	MySqlParserST_POINTN                         = 1058
	MySqlParserST_POLYFROMTEXT                   = 1059
	MySqlParserST_POLYFROMWKB                    = 1060
	MySqlParserST_POLYGONFROMTEXT                = 1061
	MySqlParserST_POLYGONFROMWKB                 = 1062
	MySqlParserST_SRID                           = 1063
	MySqlParserST_STARTPOINT                     = 1064
	MySqlParserST_SYMDIFFERENCE                  = 1065
	MySqlParserST_TOUCHES                        = 1066
	MySqlParserST_UNION                          = 1067
	MySqlParserST_WITHIN                         = 1068
	MySqlParserST_X                              = 1069
	MySqlParserST_Y                              = 1070
	MySqlParserSUBDATE                           = 1071
	MySqlParserSUBSTRING_INDEX                   = 1072
	MySqlParserSUBTIME                           = 1073
	MySqlParserSYSTEM_USER                       = 1074
	MySqlParserTAN                               = 1075
	MySqlParserTIMEDIFF                          = 1076
	MySqlParserTIMESTAMPADD                      = 1077
	MySqlParserTIMESTAMPDIFF                     = 1078
	MySqlParserTIME_FORMAT                       = 1079
	MySqlParserTIME_TO_SEC                       = 1080
	MySqlParserTOUCHES                           = 1081
	MySqlParserTO_BASE64                         = 1082
	MySqlParserTO_DAYS                           = 1083
	MySqlParserTO_SECONDS                        = 1084
	MySqlParserUCASE                             = 1085
	MySqlParserUNCOMPRESS                        = 1086
	MySqlParserUNCOMPRESSED_LENGTH               = 1087
	MySqlParserUNHEX                             = 1088
	MySqlParserUNIX_TIMESTAMP                    = 1089
	MySqlParserUPDATEXML                         = 1090
	MySqlParserUPPER                             = 1091
	MySqlParserUUID                              = 1092
	MySqlParserUUID_SHORT                        = 1093
	MySqlParserVALIDATE_PASSWORD_STRENGTH        = 1094
	MySqlParserVERSION                           = 1095
	MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS = 1096
	MySqlParserWEEKDAY                           = 1097
	MySqlParserWEEKOFYEAR                        = 1098
	MySqlParserWEIGHT_STRING                     = 1099
	MySqlParserWITHIN                            = 1100
	MySqlParserYEARWEEK                          = 1101
	MySqlParserY_FUNCTION                        = 1102
	MySqlParserX_FUNCTION                        = 1103
	MySqlParserVAR_ASSIGN                        = 1104
	MySqlParserPLUS_ASSIGN                       = 1105
	MySqlParserMINUS_ASSIGN                      = 1106
	MySqlParserMULT_ASSIGN                       = 1107
	MySqlParserDIV_ASSIGN                        = 1108
	MySqlParserMOD_ASSIGN                        = 1109
	MySqlParserAND_ASSIGN                        = 1110
	MySqlParserXOR_ASSIGN                        = 1111
	MySqlParserOR_ASSIGN                         = 1112
	MySqlParserSTAR                              = 1113
	MySqlParserDIVIDE                            = 1114
	MySqlParserMODULE                            = 1115
	MySqlParserPLUS                              = 1116
	MySqlParserMINUS                             = 1117
	MySqlParserDIV                               = 1118
	MySqlParserMOD                               = 1119
	MySqlParserEQUAL_SYMBOL                      = 1120
	MySqlParserGREATER_SYMBOL                    = 1121
	MySqlParserLESS_SYMBOL                       = 1122
	MySqlParserEXCLAMATION_SYMBOL                = 1123
	MySqlParserBIT_NOT_OP                        = 1124
	MySqlParserBIT_OR_OP                         = 1125
	MySqlParserBIT_AND_OP                        = 1126
	MySqlParserBIT_XOR_OP                        = 1127
	MySqlParserDOT                               = 1128
	MySqlParserLR_BRACKET                        = 1129
	MySqlParserRR_BRACKET                        = 1130
	MySqlParserCOMMA                             = 1131
	MySqlParserSEMI                              = 1132
	MySqlParserAT_SIGN                           = 1133
	MySqlParserZERO_DECIMAL                      = 1134
	MySqlParserONE_DECIMAL                       = 1135
	MySqlParserTWO_DECIMAL                       = 1136
	MySqlParserSINGLE_QUOTE_SYMB                 = 1137
	MySqlParserDOUBLE_QUOTE_SYMB                 = 1138
	MySqlParserREVERSE_QUOTE_SYMB                = 1139
	MySqlParserCOLON_SYMB                        = 1140
	MySqlParserLR_BRACKETS                       = 1141
	MySqlParserRR_BRACKETS                       = 1142
	MySqlParserCHARSET_REVERSE_QOUTE_STRING      = 1143
	MySqlParserFILESIZE_LITERAL                  = 1144
	MySqlParserSTART_NATIONAL_STRING_LITERAL     = 1145
	MySqlParserSTRING_LITERAL                    = 1146
	MySqlParserDECIMAL_LITERAL                   = 1147
	MySqlParserHEXADECIMAL_LITERAL               = 1148
	MySqlParserREAL_LITERAL                      = 1149
	MySqlParserNULL_SPEC_LITERAL                 = 1150
	MySqlParserBIT_STRING                        = 1151
	MySqlParserSTRING_CHARSET_NAME               = 1152
	MySqlParserDOT_ID                            = 1153
	MySqlParserID                                = 1154
	MySqlParserREVERSE_QUOTE_ID                  = 1155
	MySqlParserSTRING_USER_NAME                  = 1156
	MySqlParserIP_ADDRESS                        = 1157
	MySqlParserLOCAL_ID                          = 1158
	MySqlParserGLOBAL_ID                         = 1159
	MySqlParserERROR_RECONGNIGION                = 1160
)

// MySqlParser rules.
const (
	MySqlParserRULE_root                      = 0
	MySqlParserRULE_sqlStatements             = 1
	MySqlParserRULE_sqlStatement              = 2
	MySqlParserRULE_emptyStatement_           = 3
	MySqlParserRULE_dmlStatement              = 4
	MySqlParserRULE_selectStatement           = 5
	MySqlParserRULE_lockClause                = 6
	MySqlParserRULE_tableSources              = 7
	MySqlParserRULE_tableSource               = 8
	MySqlParserRULE_querySpecification        = 9
	MySqlParserRULE_selectSpec                = 10
	MySqlParserRULE_selectElements            = 11
	MySqlParserRULE_selectElement             = 12
	MySqlParserRULE_fromClause                = 13
	MySqlParserRULE_annsClause                = 14
	MySqlParserRULE_annsFuncClause            = 15
	MySqlParserRULE_annsArgs                  = 16
	MySqlParserRULE_limitClause               = 17
	MySqlParserRULE_limitClauseAtom           = 18
	MySqlParserRULE_fullId                    = 19
	MySqlParserRULE_tableName                 = 20
	MySqlParserRULE_fullColumnName            = 21
	MySqlParserRULE_collationName             = 22
	MySqlParserRULE_uid                       = 23
	MySqlParserRULE_simpleId                  = 24
	MySqlParserRULE_dottedId                  = 25
	MySqlParserRULE_decimalLiteral            = 26
	MySqlParserRULE_stringLiteral             = 27
	MySqlParserRULE_booleanLiteral            = 28
	MySqlParserRULE_hexadecimalLiteral        = 29
	MySqlParserRULE_constant                  = 30
	MySqlParserRULE_expressions               = 31
	MySqlParserRULE_functionCall              = 32
	MySqlParserRULE_aggregateWindowedFunction = 33
	MySqlParserRULE_expression                = 34
	MySqlParserRULE_predicate                 = 35
	MySqlParserRULE_expressionAtom            = 36
	MySqlParserRULE_array                     = 37
	MySqlParserRULE_unaryOperator             = 38
	MySqlParserRULE_comparisonOperator        = 39
	MySqlParserRULE_logicalOperator           = 40
)

// IRootContext is an interface to support dynamic dispatch.
type IRootContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRootContext differentiates from other interfaces.
	IsRootContext()
}

type RootContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootContext() *RootContext {
	var p = new(RootContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_root
	return p
}

func (*RootContext) IsRootContext() {}

func NewRootContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootContext {
	var p = new(RootContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_root

	return p
}

func (s *RootContext) GetParser() antlr.Parser { return s.parser }

func (s *RootContext) EOF() antlr.TerminalNode {
	return s.GetToken(MySqlParserEOF, 0)
}

func (s *RootContext) SqlStatements() ISqlStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementsContext)
}

func (s *RootContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserMINUS)
}

func (s *RootContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, i)
}

func (s *RootContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoot(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Root() (localctx IRootContext) {
	this := p
	_ = this

	localctx = NewRootContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, MySqlParserRULE_root)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(83)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserSELECT || _la == MySqlParserSEMI {
		{
			p.SetState(82)
			p.SqlStatements()
		}

	}
	p.SetState(87)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserMINUS {
		{
			p.SetState(85)
			p.Match(MySqlParserMINUS)
		}
		{
			p.SetState(86)
			p.Match(MySqlParserMINUS)
		}

	}
	{
		p.SetState(89)
		p.Match(MySqlParserEOF)
	}

	return localctx
}

// ISqlStatementsContext is an interface to support dynamic dispatch.
type ISqlStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSqlStatementsContext differentiates from other interfaces.
	IsSqlStatementsContext()
}

type SqlStatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementsContext() *SqlStatementsContext {
	var p = new(SqlStatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_sqlStatements
	return p
}

func (*SqlStatementsContext) IsSqlStatementsContext() {}

func NewSqlStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementsContext {
	var p = new(SqlStatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_sqlStatements

	return p
}

func (s *SqlStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementsContext) AllSqlStatement() []ISqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISqlStatementContext); ok {
			len++
		}
	}

	tst := make([]ISqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISqlStatementContext); ok {
			tst[i] = t.(ISqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) SqlStatement(i int) ISqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *SqlStatementsContext) AllEmptyStatement_() []IEmptyStatement_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			len++
		}
	}

	tst := make([]IEmptyStatement_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEmptyStatement_Context); ok {
			tst[i] = t.(IEmptyStatement_Context)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) EmptyStatement_(i int) IEmptyStatement_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *SqlStatementsContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSEMI)
}

func (s *SqlStatementsContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSEMI, i)
}

func (s *SqlStatementsContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserMINUS)
}

func (s *SqlStatementsContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, i)
}

func (s *SqlStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSqlStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SqlStatements() (localctx ISqlStatementsContext) {
	this := p
	_ = this

	localctx = NewSqlStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, MySqlParserRULE_sqlStatements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(102)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(100)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case MySqlParserSELECT:
				{
					p.SetState(91)
					p.SqlStatement()
				}
				p.SetState(94)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserMINUS {
					{
						p.SetState(92)
						p.Match(MySqlParserMINUS)
					}
					{
						p.SetState(93)
						p.Match(MySqlParserMINUS)
					}

				}
				p.SetState(97)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(96)
						p.Match(MySqlParserSEMI)
					}

				}

			case MySqlParserSEMI:
				{
					p.SetState(99)
					p.EmptyStatement_()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(104)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())
	}
	p.SetState(114)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSELECT:
		{
			p.SetState(105)
			p.SqlStatement()
		}
		p.SetState(111)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
			p.SetState(108)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserMINUS {
				{
					p.SetState(106)
					p.Match(MySqlParserMINUS)
				}
				{
					p.SetState(107)
					p.Match(MySqlParserMINUS)
				}

			}
			{
				p.SetState(110)
				p.Match(MySqlParserSEMI)
			}

		}

	case MySqlParserSEMI:
		{
			p.SetState(113)
			p.EmptyStatement_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISqlStatementContext is an interface to support dynamic dispatch.
type ISqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSqlStatementContext differentiates from other interfaces.
	IsSqlStatementContext()
}

type SqlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementContext() *SqlStatementContext {
	var p = new(SqlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_sqlStatement
	return p
}

func (*SqlStatementContext) IsSqlStatementContext() {}

func NewSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementContext {
	var p = new(SqlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_sqlStatement

	return p
}

func (s *SqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementContext) DmlStatement() IDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDmlStatementContext)
}

func (s *SqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSqlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SqlStatement() (localctx ISqlStatementContext) {
	this := p
	_ = this

	localctx = NewSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, MySqlParserRULE_sqlStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(116)
		p.DmlStatement()
	}

	return localctx
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_emptyStatement_
	return p
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatement_Context) SEMI() antlr.TerminalNode {
	return s.GetToken(MySqlParserSEMI, 0)
}

func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitEmptyStatement_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	this := p
	_ = this

	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, MySqlParserRULE_emptyStatement_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(118)
		p.Match(MySqlParserSEMI)
	}

	return localctx
}

// IDmlStatementContext is an interface to support dynamic dispatch.
type IDmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDmlStatementContext differentiates from other interfaces.
	IsDmlStatementContext()
}

type DmlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDmlStatementContext() *DmlStatementContext {
	var p = new(DmlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dmlStatement
	return p
}

func (*DmlStatementContext) IsDmlStatementContext() {}

func NewDmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DmlStatementContext {
	var p = new(DmlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dmlStatement

	return p
}

func (s *DmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DmlStatementContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *DmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DmlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDmlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DmlStatement() (localctx IDmlStatementContext) {
	this := p
	_ = this

	localctx = NewDmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, MySqlParserRULE_dmlStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(120)
		p.SelectStatement()
	}

	return localctx
}

// ISelectStatementContext is an interface to support dynamic dispatch.
type ISelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectStatementContext differentiates from other interfaces.
	IsSelectStatementContext()
}

type SelectStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStatementContext() *SelectStatementContext {
	var p = new(SelectStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectStatement
	return p
}

func (*SelectStatementContext) IsSelectStatementContext() {}

func NewSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementContext {
	var p = new(SelectStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectStatement

	return p
}

func (s *SelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementContext) CopyFrom(ctx *SelectStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SimpleSelectContext struct {
	*SelectStatementContext
}

func NewSimpleSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleSelectContext {
	var p = new(SimpleSelectContext)

	p.SelectStatementContext = NewEmptySelectStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectStatementContext))

	return p
}

func (s *SimpleSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleSelectContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *SimpleSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *SimpleSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectStatement() (localctx ISelectStatementContext) {
	this := p
	_ = this

	localctx = NewSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, MySqlParserRULE_selectStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewSimpleSelectContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(122)
		p.QuerySpecification()
	}
	p.SetState(124)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFOR || _la == MySqlParserLOCK {
		{
			p.SetState(123)
			p.LockClause()
		}

	}

	return localctx
}

// ILockClauseContext is an interface to support dynamic dispatch.
type ILockClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLockClauseContext differentiates from other interfaces.
	IsLockClauseContext()
}

type LockClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockClauseContext() *LockClauseContext {
	var p = new(LockClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_lockClause
	return p
}

func (*LockClauseContext) IsLockClauseContext() {}

func NewLockClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockClauseContext {
	var p = new(LockClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lockClause

	return p
}

func (s *LockClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LockClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *LockClauseContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *LockClauseContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *LockClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *LockClauseContext) SHARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARE, 0)
}

func (s *LockClauseContext) MODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODE, 0)
}

func (s *LockClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLockClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LockClause() (localctx ILockClauseContext) {
	this := p
	_ = this

	localctx = NewLockClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, MySqlParserRULE_lockClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(132)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(126)
			p.Match(MySqlParserFOR)
		}
		{
			p.SetState(127)
			p.Match(MySqlParserUPDATE)
		}

	case MySqlParserLOCK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(128)
			p.Match(MySqlParserLOCK)
		}
		{
			p.SetState(129)
			p.Match(MySqlParserIN)
		}
		{
			p.SetState(130)
			p.Match(MySqlParserSHARE)
		}
		{
			p.SetState(131)
			p.Match(MySqlParserMODE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITableSourcesContext is an interface to support dynamic dispatch.
type ITableSourcesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableSourcesContext differentiates from other interfaces.
	IsTableSourcesContext()
}

type TableSourcesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourcesContext() *TableSourcesContext {
	var p = new(TableSourcesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSources
	return p
}

func (*TableSourcesContext) IsTableSourcesContext() {}

func NewTableSourcesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourcesContext {
	var p = new(TableSourcesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableSources

	return p
}

func (s *TableSourcesContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourcesContext) AllTableSource() []ITableSourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableSourceContext); ok {
			len++
		}
	}

	tst := make([]ITableSourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableSourceContext); ok {
			tst[i] = t.(ITableSourceContext)
			i++
		}
	}

	return tst
}

func (s *TableSourcesContext) TableSource(i int) ITableSourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceContext)
}

func (s *TableSourcesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *TableSourcesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *TableSourcesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourcesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableSourcesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableSources(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableSources() (localctx ITableSourcesContext) {
	this := p
	_ = this

	localctx = NewTableSourcesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, MySqlParserRULE_tableSources)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(134)
		p.TableSource()
	}
	p.SetState(139)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(135)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(136)
			p.TableSource()
		}

		p.SetState(141)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITableSourceContext is an interface to support dynamic dispatch.
type ITableSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableSourceContext differentiates from other interfaces.
	IsTableSourceContext()
}

type TableSourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourceContext() *TableSourceContext {
	var p = new(TableSourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSource
	return p
}

func (*TableSourceContext) IsTableSourceContext() {}

func NewTableSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourceContext {
	var p = new(TableSourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableSource

	return p
}

func (s *TableSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourceContext) CopyFrom(ctx *TableSourceContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TableSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableSourceBaseContext struct {
	*TableSourceContext
}

func NewTableSourceBaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourceBaseContext {
	var p = new(TableSourceBaseContext)

	p.TableSourceContext = NewEmptyTableSourceContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableSourceContext))

	return p
}

func (s *TableSourceBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceBaseContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableSourceBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableSourceBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableSource() (localctx ITableSourceContext) {
	this := p
	_ = this

	localctx = NewTableSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, MySqlParserRULE_tableSource)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewTableSourceBaseContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(142)
		p.TableName()
	}

	return localctx
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_querySpecification
	return p
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) SELECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSELECT, 0)
}

func (s *QuerySpecificationContext) SelectElements() ISelectElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementsContext)
}

func (s *QuerySpecificationContext) AllSelectSpec() []ISelectSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectSpecContext); ok {
			len++
		}
	}

	tst := make([]ISelectSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectSpecContext); ok {
			tst[i] = t.(ISelectSpecContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectSpec(i int) ISelectSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectSpecContext)
}

func (s *QuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationContext) AnnsClause() IAnnsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnsClauseContext)
}

func (s *QuerySpecificationContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitQuerySpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	this := p
	_ = this

	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, MySqlParserRULE_querySpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(144)
		p.Match(MySqlParserSELECT)
	}
	p.SetState(148)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(145)
				p.SelectSpec()
			}

		}
		p.SetState(150)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())
	}
	{
		p.SetState(151)
		p.SelectElements()
	}
	p.SetState(153)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFROM {
		{
			p.SetState(152)
			p.FromClause()
		}

	}
	p.SetState(156)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserANNS {
		{
			p.SetState(155)
			p.AnnsClause()
		}

	}
	p.SetState(159)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLIMIT {
		{
			p.SetState(158)
			p.LimitClause()
		}

	}

	return localctx
}

// ISelectSpecContext is an interface to support dynamic dispatch.
type ISelectSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectSpecContext differentiates from other interfaces.
	IsSelectSpecContext()
}

type SelectSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectSpecContext() *SelectSpecContext {
	var p = new(SelectSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectSpec
	return p
}

func (*SelectSpecContext) IsSelectSpecContext() {}

func NewSelectSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectSpecContext {
	var p = new(SelectSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectSpec

	return p
}

func (s *SelectSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectSpecContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *SelectSpecContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *SelectSpecContext) DISTINCTROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCTROW, 0)
}

func (s *SelectSpecContext) HIGH_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserHIGH_PRIORITY, 0)
}

func (s *SelectSpecContext) STRAIGHT_JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRAIGHT_JOIN, 0)
}

func (s *SelectSpecContext) SQL_SMALL_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_SMALL_RESULT, 0)
}

func (s *SelectSpecContext) SQL_BIG_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BIG_RESULT, 0)
}

func (s *SelectSpecContext) SQL_BUFFER_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BUFFER_RESULT, 0)
}

func (s *SelectSpecContext) SQL_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_CACHE, 0)
}

func (s *SelectSpecContext) SQL_NO_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_NO_CACHE, 0)
}

func (s *SelectSpecContext) SQL_CALC_FOUND_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_CALC_FOUND_ROWS, 0)
}

func (s *SelectSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectSpec() (localctx ISelectSpecContext) {
	this := p
	_ = this

	localctx = NewSelectSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, MySqlParserRULE_selectSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(169)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserALL, MySqlParserDISTINCT, MySqlParserDISTINCTROW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(161)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1688849860264000) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserHIGH_PRIORITY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(162)
			p.Match(MySqlParserHIGH_PRIORITY)
		}

	case MySqlParserSTRAIGHT_JOIN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(163)
			p.Match(MySqlParserSTRAIGHT_JOIN)
		}

	case MySqlParserSQL_SMALL_RESULT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(164)
			p.Match(MySqlParserSQL_SMALL_RESULT)
		}

	case MySqlParserSQL_BIG_RESULT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(165)
			p.Match(MySqlParserSQL_BIG_RESULT)
		}

	case MySqlParserSQL_BUFFER_RESULT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(166)
			p.Match(MySqlParserSQL_BUFFER_RESULT)
		}

	case MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(167)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSQL_CACHE || _la == MySqlParserSQL_NO_CACHE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserSQL_CALC_FOUND_ROWS:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(168)
			p.Match(MySqlParserSQL_CALC_FOUND_ROWS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISelectElementsContext is an interface to support dynamic dispatch.
type ISelectElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStar returns the star token.
	GetStar() antlr.Token

	// SetStar sets the star token.
	SetStar(antlr.Token)

	// IsSelectElementsContext differentiates from other interfaces.
	IsSelectElementsContext()
}

type SelectElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	star   antlr.Token
}

func NewEmptySelectElementsContext() *SelectElementsContext {
	var p = new(SelectElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectElements
	return p
}

func (*SelectElementsContext) IsSelectElementsContext() {}

func NewSelectElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementsContext {
	var p = new(SelectElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectElements

	return p
}

func (s *SelectElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementsContext) GetStar() antlr.Token { return s.star }

func (s *SelectElementsContext) SetStar(v antlr.Token) { s.star = v }

func (s *SelectElementsContext) AllSelectElement() []ISelectElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectElementContext); ok {
			len++
		}
	}

	tst := make([]ISelectElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectElementContext); ok {
			tst[i] = t.(ISelectElementContext)
			i++
		}
	}

	return tst
}

func (s *SelectElementsContext) SelectElement(i int) ISelectElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementContext)
}

func (s *SelectElementsContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *SelectElementsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SelectElementsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SelectElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectElements() (localctx ISelectElementsContext) {
	this := p
	_ = this

	localctx = NewSelectElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, MySqlParserRULE_selectElements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(173)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(171)

			var _m = p.Match(MySqlParserSTAR)

			localctx.(*SelectElementsContext).star = _m
		}

	case 2:
		{
			p.SetState(172)
			p.SelectElement()
		}

	}
	p.SetState(179)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(175)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(176)
			p.SelectElement()
		}

		p.SetState(181)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISelectElementContext is an interface to support dynamic dispatch.
type ISelectElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectElementContext differentiates from other interfaces.
	IsSelectElementContext()
}

type SelectElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectElementContext() *SelectElementContext {
	var p = new(SelectElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectElement
	return p
}

func (*SelectElementContext) IsSelectElementContext() {}

func NewSelectElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementContext {
	var p = new(SelectElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectElement

	return p
}

func (s *SelectElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementContext) CopyFrom(ctx *SelectElementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectFunctionElementContext struct {
	*SelectElementContext
}

func NewSelectFunctionElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectFunctionElementContext {
	var p = new(SelectFunctionElementContext)

	p.SelectElementContext = NewEmptySelectElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectElementContext))

	return p
}

func (s *SelectFunctionElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectFunctionElementContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *SelectFunctionElementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectFunctionElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SelectFunctionElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectFunctionElement(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectColumnElementContext struct {
	*SelectElementContext
}

func NewSelectColumnElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectColumnElementContext {
	var p = new(SelectColumnElementContext)

	p.SelectElementContext = NewEmptySelectElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectElementContext))

	return p
}

func (s *SelectColumnElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectColumnElementContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *SelectColumnElementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectColumnElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SelectColumnElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectColumnElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectElement() (localctx ISelectElementContext) {
	this := p
	_ = this

	localctx = NewSelectElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, MySqlParserRULE_selectElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(196)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectColumnElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(182)
			p.FullColumnName()
		}
		p.SetState(187)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS || (int64((_la-1143)) & ^0x3f) == 0 && ((int64(1)<<(_la-1143))&6145) != 0 {
			p.SetState(184)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(183)
					p.Match(MySqlParserAS)
				}

			}
			{
				p.SetState(186)
				p.Uid()
			}

		}

	case 2:
		localctx = NewSelectFunctionElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(189)
			p.FunctionCall()
		}
		p.SetState(194)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS || (int64((_la-1143)) & ^0x3f) == 0 && ((int64(1)<<(_la-1143))&6145) != 0 {
			p.SetState(191)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(190)
					p.Match(MySqlParserAS)
				}

			}
			{
				p.SetState(193)
				p.Uid()
			}

		}

	}

	return localctx
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhereExpr returns the whereExpr rule contexts.
	GetWhereExpr() IExpressionContext

	// SetWhereExpr sets the whereExpr rule contexts.
	SetWhereExpr(IExpressionContext)

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	whereExpr IExpressionContext
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_fromClause
	return p
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) GetWhereExpr() IExpressionContext { return s.whereExpr }

func (s *FromClauseContext) SetWhereExpr(v IExpressionContext) { s.whereExpr = v }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *FromClauseContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *FromClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *FromClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFromClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FromClause() (localctx IFromClauseContext) {
	this := p
	_ = this

	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, MySqlParserRULE_fromClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(198)
		p.Match(MySqlParserFROM)
	}
	{
		p.SetState(199)
		p.TableSources()
	}

	p.SetState(203)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWHERE {
		{
			p.SetState(201)
			p.Match(MySqlParserWHERE)
		}
		{
			p.SetState(202)

			var _x = p.expression(0)

			localctx.(*FromClauseContext).whereExpr = _x
		}

	}

	return localctx
}

// IAnnsClauseContext is an interface to support dynamic dispatch.
type IAnnsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnsClauseContext differentiates from other interfaces.
	IsAnnsClauseContext()
}

type AnnsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnsClauseContext() *AnnsClauseContext {
	var p = new(AnnsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_annsClause
	return p
}

func (*AnnsClauseContext) IsAnnsClauseContext() {}

func NewAnnsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnsClauseContext {
	var p = new(AnnsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_annsClause

	return p
}

func (s *AnnsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnsClauseContext) ANNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserANNS, 0)
}

func (s *AnnsClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *AnnsClauseContext) AnnsFuncClause() IAnnsFuncClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnsFuncClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnsFuncClauseContext)
}

func (s *AnnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAnnsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AnnsClause() (localctx IAnnsClauseContext) {
	this := p
	_ = this

	localctx = NewAnnsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, MySqlParserRULE_annsClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(205)
		p.Match(MySqlParserANNS)
	}
	{
		p.SetState(206)
		p.Match(MySqlParserBY)
	}
	{
		p.SetState(207)
		p.AnnsFuncClause()
	}

	return localctx
}

// IAnnsFuncClauseContext is an interface to support dynamic dispatch.
type IAnnsFuncClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFunc_ returns the func_ token.
	GetFunc_() antlr.Token

	// SetFunc_ sets the func_ token.
	SetFunc_(antlr.Token)

	// IsAnnsFuncClauseContext differentiates from other interfaces.
	IsAnnsFuncClauseContext()
}

type AnnsFuncClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	func_  antlr.Token
}

func NewEmptyAnnsFuncClauseContext() *AnnsFuncClauseContext {
	var p = new(AnnsFuncClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_annsFuncClause
	return p
}

func (*AnnsFuncClauseContext) IsAnnsFuncClauseContext() {}

func NewAnnsFuncClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnsFuncClauseContext {
	var p = new(AnnsFuncClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_annsFuncClause

	return p
}

func (s *AnnsFuncClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnsFuncClauseContext) GetFunc_() antlr.Token { return s.func_ }

func (s *AnnsFuncClauseContext) SetFunc_(v antlr.Token) { s.func_ = v }

func (s *AnnsFuncClauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AnnsFuncClauseContext) AnnsArgs() IAnnsArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnsArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnsArgsContext)
}

func (s *AnnsFuncClauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AnnsFuncClauseContext) L2() antlr.TerminalNode {
	return s.GetToken(MySqlParserL2, 0)
}

func (s *AnnsFuncClauseContext) IP() antlr.TerminalNode {
	return s.GetToken(MySqlParserIP, 0)
}

func (s *AnnsFuncClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnsFuncClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnsFuncClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAnnsFuncClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AnnsFuncClause() (localctx IAnnsFuncClauseContext) {
	this := p
	_ = this

	localctx = NewAnnsFuncClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, MySqlParserRULE_annsFuncClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(209)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*AnnsFuncClauseContext).func_ = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserL2 || _la == MySqlParserIP) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*AnnsFuncClauseContext).func_ = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(210)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(211)
		p.AnnsArgs()
	}
	{
		p.SetState(212)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// IAnnsArgsContext is an interface to support dynamic dispatch.
type IAnnsArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnsArgsContext differentiates from other interfaces.
	IsAnnsArgsContext()
}

type AnnsArgsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnsArgsContext() *AnnsArgsContext {
	var p = new(AnnsArgsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_annsArgs
	return p
}

func (*AnnsArgsContext) IsAnnsArgsContext() {}

func NewAnnsArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnsArgsContext {
	var p = new(AnnsArgsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_annsArgs

	return p
}

func (s *AnnsArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnsArgsContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AnnsArgsContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AnnsArgsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AnnsArgsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AnnsArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnsArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnsArgsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAnnsArgs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AnnsArgs() (localctx IAnnsArgsContext) {
	this := p
	_ = this

	localctx = NewAnnsArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, MySqlParserRULE_annsArgs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(222)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(214)
			p.expression(0)
		}
		p.SetState(219)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(215)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(216)
				p.expression(0)
			}

			p.SetState(221)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOffset returns the offset rule contexts.
	GetOffset() ILimitClauseAtomContext

	// GetLimit returns the limit rule contexts.
	GetLimit() ILimitClauseAtomContext

	// SetOffset sets the offset rule contexts.
	SetOffset(ILimitClauseAtomContext)

	// SetLimit sets the limit rule contexts.
	SetLimit(ILimitClauseAtomContext)

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	offset ILimitClauseAtomContext
	limit  ILimitClauseAtomContext
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_limitClause
	return p
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) GetOffset() ILimitClauseAtomContext { return s.offset }

func (s *LimitClauseContext) GetLimit() ILimitClauseAtomContext { return s.limit }

func (s *LimitClauseContext) SetOffset(v ILimitClauseAtomContext) { s.offset = v }

func (s *LimitClauseContext) SetLimit(v ILimitClauseAtomContext) { s.limit = v }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *LimitClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFSET, 0)
}

func (s *LimitClauseContext) AllLimitClauseAtom() []ILimitClauseAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			len++
		}
	}

	tst := make([]ILimitClauseAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILimitClauseAtomContext); ok {
			tst[i] = t.(ILimitClauseAtomContext)
			i++
		}
	}

	return tst
}

func (s *LimitClauseContext) LimitClauseAtom(i int) ILimitClauseAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *LimitClauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LimitClause() (localctx ILimitClauseContext) {
	this := p
	_ = this

	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, MySqlParserRULE_limitClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(224)
		p.Match(MySqlParserLIMIT)
	}
	p.SetState(235)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		p.SetState(228)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(225)

				var _x = p.LimitClauseAtom()

				localctx.(*LimitClauseContext).offset = _x
			}
			{
				p.SetState(226)
				p.Match(MySqlParserCOMMA)
			}

		}
		{
			p.SetState(230)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).limit = _x
		}

	case 2:
		{
			p.SetState(231)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).limit = _x
		}
		{
			p.SetState(232)
			p.Match(MySqlParserOFFSET)
		}
		{
			p.SetState(233)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).offset = _x
		}

	}

	return localctx
}

// ILimitClauseAtomContext is an interface to support dynamic dispatch.
type ILimitClauseAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimitClauseAtomContext differentiates from other interfaces.
	IsLimitClauseAtomContext()
}

type LimitClauseAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseAtomContext() *LimitClauseAtomContext {
	var p = new(LimitClauseAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_limitClauseAtom
	return p
}

func (*LimitClauseAtomContext) IsLimitClauseAtomContext() {}

func NewLimitClauseAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseAtomContext {
	var p = new(LimitClauseAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_limitClauseAtom

	return p
}

func (s *LimitClauseAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseAtomContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LimitClauseAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLimitClauseAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LimitClauseAtom() (localctx ILimitClauseAtomContext) {
	this := p
	_ = this

	localctx = NewLimitClauseAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, MySqlParserRULE_limitClauseAtom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(237)
		p.DecimalLiteral()
	}

	return localctx
}

// IFullIdContext is an interface to support dynamic dispatch.
type IFullIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFullIdContext differentiates from other interfaces.
	IsFullIdContext()
}

type FullIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullIdContext() *FullIdContext {
	var p = new(FullIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_fullId
	return p
}

func (*FullIdContext) IsFullIdContext() {}

func NewFullIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullIdContext {
	var p = new(FullIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullId

	return p
}

func (s *FullIdContext) GetParser() antlr.Parser { return s.parser }

func (s *FullIdContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *FullIdContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT_ID, 0)
}

func (s *FullIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *FullIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FullId() (localctx IFullIdContext) {
	this := p
	_ = this

	localctx = NewFullIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, MySqlParserRULE_fullId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(239)
		p.Uid()
	}
	p.SetState(243)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDOT_ID:
		{
			p.SetState(240)
			p.Match(MySqlParserDOT_ID)
		}

	case MySqlParserDOT:
		{
			p.SetState(241)
			p.Match(MySqlParserDOT)
		}
		{
			p.SetState(242)
			p.Uid()
		}

	case MySqlParserEOF, MySqlParserFOR, MySqlParserLIMIT, MySqlParserLOCK, MySqlParserSELECT, MySqlParserWHERE, MySqlParserANNS, MySqlParserMINUS, MySqlParserCOMMA, MySqlParserSEMI:

	default:
	}

	return localctx
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableName
	return p
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableName() (localctx ITableNameContext) {
	this := p
	_ = this

	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, MySqlParserRULE_tableName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(245)
		p.FullId()
	}

	return localctx
}

// IFullColumnNameContext is an interface to support dynamic dispatch.
type IFullColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFullColumnNameContext differentiates from other interfaces.
	IsFullColumnNameContext()
}

type FullColumnNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullColumnNameContext() *FullColumnNameContext {
	var p = new(FullColumnNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_fullColumnName
	return p
}

func (*FullColumnNameContext) IsFullColumnNameContext() {}

func NewFullColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullColumnNameContext {
	var p = new(FullColumnNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullColumnName

	return p
}

func (s *FullColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FullColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullColumnNameContext) AllDottedId() []IDottedIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDottedIdContext); ok {
			len++
		}
	}

	tst := make([]IDottedIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDottedIdContext); ok {
			tst[i] = t.(IDottedIdContext)
			i++
		}
	}

	return tst
}

func (s *FullColumnNameContext) DottedId(i int) IDottedIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDottedIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDottedIdContext)
}

func (s *FullColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FullColumnName() (localctx IFullColumnNameContext) {
	this := p
	_ = this

	localctx = NewFullColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, MySqlParserRULE_fullColumnName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(261)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(247)
			p.Uid()
		}
		p.SetState(252)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(248)
				p.DottedId()
			}
			p.SetState(250)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(249)
					p.DottedId()
				}

			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(255)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
			p.SetState(254)
			p.MatchWildcard()

		}
		{
			p.SetState(257)
			p.DottedId()
		}
		p.SetState(259)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(258)
				p.DottedId()
			}

		}

	}

	return localctx
}

// ICollationNameContext is an interface to support dynamic dispatch.
type ICollationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollationNameContext differentiates from other interfaces.
	IsCollationNameContext()
}

type CollationNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollationNameContext() *CollationNameContext {
	var p = new(CollationNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_collationName
	return p
}

func (*CollationNameContext) IsCollationNameContext() {}

func NewCollationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollationNameContext {
	var p = new(CollationNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_collationName

	return p
}

func (s *CollationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CollationNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CollationNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CollationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollationNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCollationName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CollationName() (localctx ICollationNameContext) {
	this := p
	_ = this

	localctx = NewCollationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, MySqlParserRULE_collationName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(265)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(263)
			p.Uid()
		}

	case MySqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(264)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUidContext is an interface to support dynamic dispatch.
type IUidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUidContext differentiates from other interfaces.
	IsUidContext()
}

type UidContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUidContext() *UidContext {
	var p = new(UidContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_uid
	return p
}

func (*UidContext) IsUidContext() {}

func NewUidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidContext {
	var p = new(UidContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_uid

	return p
}

func (s *UidContext) GetParser() antlr.Parser { return s.parser }

func (s *UidContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *UidContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE_QUOTE_ID, 0)
}

func (s *UidContext) CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET_REVERSE_QOUTE_STRING, 0)
}

func (s *UidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Uid() (localctx IUidContext) {
	this := p
	_ = this

	localctx = NewUidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, MySqlParserRULE_uid)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(270)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(267)
			p.SimpleId()
		}

	case MySqlParserREVERSE_QUOTE_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(268)
			p.Match(MySqlParserREVERSE_QUOTE_ID)
		}

	case MySqlParserCHARSET_REVERSE_QOUTE_STRING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(269)
			p.Match(MySqlParserCHARSET_REVERSE_QOUTE_STRING)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISimpleIdContext is an interface to support dynamic dispatch.
type ISimpleIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleIdContext differentiates from other interfaces.
	IsSimpleIdContext()
}

type SimpleIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleIdContext() *SimpleIdContext {
	var p = new(SimpleIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleId
	return p
}

func (*SimpleIdContext) IsSimpleIdContext() {}

func NewSimpleIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleIdContext {
	var p = new(SimpleIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_simpleId

	return p
}

func (s *SimpleIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleIdContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *SimpleIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SimpleId() (localctx ISimpleIdContext) {
	this := p
	_ = this

	localctx = NewSimpleIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, MySqlParserRULE_simpleId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(272)
		p.Match(MySqlParserID)
	}

	return localctx
}

// IDottedIdContext is an interface to support dynamic dispatch.
type IDottedIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDottedIdContext differentiates from other interfaces.
	IsDottedIdContext()
}

type DottedIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDottedIdContext() *DottedIdContext {
	var p = new(DottedIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dottedId
	return p
}

func (*DottedIdContext) IsDottedIdContext() {}

func NewDottedIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DottedIdContext {
	var p = new(DottedIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dottedId

	return p
}

func (s *DottedIdContext) GetParser() antlr.Parser { return s.parser }

func (s *DottedIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT_ID, 0)
}

func (s *DottedIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *DottedIdContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DottedIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DottedIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DottedIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDottedId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DottedId() (localctx IDottedIdContext) {
	this := p
	_ = this

	localctx = NewDottedIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, MySqlParserRULE_dottedId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(277)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDOT_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(274)
			p.Match(MySqlParserDOT_ID)
		}

	case MySqlParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(275)
			p.Match(MySqlParserDOT)
		}
		{
			p.SetState(276)
			p.Uid()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDecimalLiteralContext is an interface to support dynamic dispatch.
type IDecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecimalLiteralContext differentiates from other interfaces.
	IsDecimalLiteralContext()
}

type DecimalLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalLiteralContext() *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_decimalLiteral
	return p
}

func (*DecimalLiteralContext) IsDecimalLiteralContext() {}

func NewDecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_decimalLiteral

	return p
}

func (s *DecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *DecimalLiteralContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTWO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDecimalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DecimalLiteral() (localctx IDecimalLiteralContext) {
	this := p
	_ = this

	localctx = NewDecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, MySqlParserRULE_decimalLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(279)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-1134)) & ^0x3f) == 0 && ((int64(1)<<(_la-1134))&40967) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *StringLiteralContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *StringLiteralContext) START_NATIONAL_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART_NATIONAL_STRING_LITERAL, 0)
}

func (s *StringLiteralContext) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_CHARSET_NAME, 0)
}

func (s *StringLiteralContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *StringLiteralContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) StringLiteral() (localctx IStringLiteralContext) {
	this := p
	_ = this

	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, MySqlParserRULE_stringLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(304)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(286)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSTRING_LITERAL, MySqlParserSTRING_CHARSET_NAME:
			p.SetState(282)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserSTRING_CHARSET_NAME {
				{
					p.SetState(281)
					p.Match(MySqlParserSTRING_CHARSET_NAME)
				}

			}
			{
				p.SetState(284)
				p.Match(MySqlParserSTRING_LITERAL)
			}

		case MySqlParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(285)
				p.Match(MySqlParserSTART_NATIONAL_STRING_LITERAL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(289)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(288)
					p.Match(MySqlParserSTRING_LITERAL)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(291)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(298)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSTRING_LITERAL, MySqlParserSTRING_CHARSET_NAME:
			p.SetState(294)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserSTRING_CHARSET_NAME {
				{
					p.SetState(293)
					p.Match(MySqlParserSTRING_CHARSET_NAME)
				}

			}
			{
				p.SetState(296)
				p.Match(MySqlParserSTRING_LITERAL)
			}

		case MySqlParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(297)
				p.Match(MySqlParserSTART_NATIONAL_STRING_LITERAL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(302)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(300)
				p.Match(MySqlParserCOLLATE)
			}
			{
				p.SetState(301)
				p.CollationName()
			}

		}

	}

	return localctx
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_booleanLiteral
	return p
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	this := p
	_ = this

	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, MySqlParserRULE_booleanLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(306)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserFALSE || _la == MySqlParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IHexadecimalLiteralContext is an interface to support dynamic dispatch.
type IHexadecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHexadecimalLiteralContext differentiates from other interfaces.
	IsHexadecimalLiteralContext()
}

type HexadecimalLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexadecimalLiteralContext() *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_hexadecimalLiteral
	return p
}

func (*HexadecimalLiteralContext) IsHexadecimalLiteralContext() {}

func NewHexadecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_hexadecimalLiteral

	return p
}

func (s *HexadecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *HexadecimalLiteralContext) HEXADECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserHEXADECIMAL_LITERAL, 0)
}

func (s *HexadecimalLiteralContext) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_CHARSET_NAME, 0)
}

func (s *HexadecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexadecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexadecimalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHexadecimalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) HexadecimalLiteral() (localctx IHexadecimalLiteralContext) {
	this := p
	_ = this

	localctx = NewHexadecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, MySqlParserRULE_hexadecimalLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(309)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserSTRING_CHARSET_NAME {
		{
			p.SetState(308)
			p.Match(MySqlParserSTRING_CHARSET_NAME)
		}

	}
	{
		p.SetState(311)
		p.Match(MySqlParserHEXADECIMAL_LITERAL)
	}

	return localctx
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_constant
	return p
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ConstantContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ConstantContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *ConstantContext) HexadecimalLiteral() IHexadecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexadecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexadecimalLiteralContext)
}

func (s *ConstantContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *ConstantContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL_LITERAL, 0)
}

func (s *ConstantContext) BIT_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_STRING, 0)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Constant() (localctx IConstantContext) {
	this := p
	_ = this

	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, MySqlParserRULE_constant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(321)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(313)
			p.StringLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(314)
			p.DecimalLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(315)
			p.Match(MySqlParserMINUS)
		}
		{
			p.SetState(316)
			p.DecimalLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(317)
			p.HexadecimalLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(318)
			p.BooleanLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(319)
			p.Match(MySqlParserREAL_LITERAL)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(320)
			p.Match(MySqlParserBIT_STRING)
		}

	}

	return localctx
}

// IExpressionsContext is an interface to support dynamic dispatch.
type IExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionsContext differentiates from other interfaces.
	IsExpressionsContext()
}

type ExpressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsContext() *ExpressionsContext {
	var p = new(ExpressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_expressions
	return p
}

func (*ExpressionsContext) IsExpressionsContext() {}

func NewExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsContext {
	var p = new(ExpressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressions

	return p
}

func (s *ExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionsContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ExpressionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Expressions() (localctx IExpressionsContext) {
	this := p
	_ = this

	localctx = NewExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, MySqlParserRULE_expressions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(323)
		p.expression(0)
	}
	p.SetState(328)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(324)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(325)
			p.expression(0)
		}

		p.SetState(330)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_functionCall
	return p
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) CopyFrom(ctx *FunctionCallContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AggregateFunctionCallContext struct {
	*FunctionCallContext
}

func NewAggregateFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregateFunctionCallContext {
	var p = new(AggregateFunctionCallContext)

	p.FunctionCallContext = NewEmptyFunctionCallContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FunctionCallContext))

	return p
}

func (s *AggregateFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateFunctionCallContext) AggregateWindowedFunction() IAggregateWindowedFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregateWindowedFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregateWindowedFunctionContext)
}

func (s *AggregateFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAggregateFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FunctionCall() (localctx IFunctionCallContext) {
	this := p
	_ = this

	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, MySqlParserRULE_functionCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewAggregateFunctionCallContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(331)
		p.AggregateWindowedFunction()
	}

	return localctx
}

// IAggregateWindowedFunctionContext is an interface to support dynamic dispatch.
type IAggregateWindowedFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStarArg returns the starArg token.
	GetStarArg() antlr.Token

	// SetStarArg sets the starArg token.
	SetStarArg(antlr.Token)

	// IsAggregateWindowedFunctionContext differentiates from other interfaces.
	IsAggregateWindowedFunctionContext()
}

type AggregateWindowedFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser  antlr.Parser
	starArg antlr.Token
}

func NewEmptyAggregateWindowedFunctionContext() *AggregateWindowedFunctionContext {
	var p = new(AggregateWindowedFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_aggregateWindowedFunction
	return p
}

func (*AggregateWindowedFunctionContext) IsAggregateWindowedFunctionContext() {}

func NewAggregateWindowedFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregateWindowedFunctionContext {
	var p = new(AggregateWindowedFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_aggregateWindowedFunction

	return p
}

func (s *AggregateWindowedFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregateWindowedFunctionContext) GetStarArg() antlr.Token { return s.starArg }

func (s *AggregateWindowedFunctionContext) SetStarArg(v antlr.Token) { s.starArg = v }

func (s *AggregateWindowedFunctionContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOUNT, 0)
}

func (s *AggregateWindowedFunctionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AggregateWindowedFunctionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AggregateWindowedFunctionContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *AggregateWindowedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateWindowedFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregateWindowedFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAggregateWindowedFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AggregateWindowedFunction() (localctx IAggregateWindowedFunctionContext) {
	this := p
	_ = this

	localctx = NewAggregateWindowedFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, MySqlParserRULE_aggregateWindowedFunction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(333)
		p.Match(MySqlParserCOUNT)
	}
	{
		p.SetState(334)
		p.Match(MySqlParserLR_BRACKET)
	}

	{
		p.SetState(335)

		var _m = p.Match(MySqlParserSTAR)

		localctx.(*AggregateWindowedFunctionContext).starArg = _m
	}

	{
		p.SetState(336)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyFrom(ctx *ExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IsExpressionContext struct {
	*ExpressionContext
	testValue antlr.Token
}

func NewIsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsExpressionContext {
	var p = new(IsExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *IsExpressionContext) GetTestValue() antlr.Token { return s.testValue }

func (s *IsExpressionContext) SetTestValue(v antlr.Token) { s.testValue = v }

func (s *IsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsExpressionContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *IsExpressionContext) IS() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS, 0)
}

func (s *IsExpressionContext) TRUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUE, 0)
}

func (s *IsExpressionContext) FALSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFALSE, 0)
}

func (s *IsExpressionContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNKNOWN, 0)
}

func (s *IsExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *IsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NotExpressionContext struct {
	*ExpressionContext
	notOperator antlr.Token
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *NotExpressionContext) GetNotOperator() antlr.Token { return s.notOperator }

func (s *NotExpressionContext) SetNotOperator(v antlr.Token) { s.notOperator = v }

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NotExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *NotExpressionContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *NotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalExpressionContext struct {
	*ExpressionContext
}

func NewLogicalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalExpressionContext) LogicalOperator() ILogicalOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOperatorContext)
}

func (s *LogicalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLogicalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PredicateExpressionContext struct {
	*ExpressionContext
}

func NewPredicateExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExpressionContext {
	var p = new(PredicateExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PredicateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExpressionContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicateExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPredicateExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *MySqlParser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 68
	p.EnterRecursionRule(localctx, 68, MySqlParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(349)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(339)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NotExpressionContext).notOperator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNOT || _la == MySqlParserEXCLAMATION_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NotExpressionContext).notOperator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(340)
			p.expression(4)
		}

	case 2:
		localctx = NewIsExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(341)
			p.predicate(0)
		}
		{
			p.SetState(342)
			p.Match(MySqlParserIS)
		}
		p.SetState(344)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(343)
				p.Match(MySqlParserNOT)
			}

		}
		{
			p.SetState(346)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IsExpressionContext).testValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFALSE || _la == MySqlParserTRUE || _la == MySqlParserUNKNOWN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IsExpressionContext).testValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		localctx = NewPredicateExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(348)
			p.predicate(0)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(357)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expression)
			p.SetState(351)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
			}
			{
				p.SetState(352)
				p.LogicalOperator()
			}
			{
				p.SetState(353)
				p.expression(4)
			}

		}
		p.SetState(359)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())
	}

	return localctx
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) CopyFrom(ctx *PredicateContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExpressionAtomPredicateContext struct {
	*PredicateContext
}

func NewExpressionAtomPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpressionAtomPredicateContext {
	var p = new(ExpressionAtomPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *ExpressionAtomPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomPredicateContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *ExpressionAtomPredicateContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *ExpressionAtomPredicateContext) VAR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_ASSIGN, 0)
}

func (s *ExpressionAtomPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExpressionAtomPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type BinaryComparisonPredicateContext struct {
	*PredicateContext
	left  IPredicateContext
	right IPredicateContext
}

func NewBinaryComparisonPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryComparisonPredicateContext {
	var p = new(BinaryComparisonPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *BinaryComparisonPredicateContext) GetLeft() IPredicateContext { return s.left }

func (s *BinaryComparisonPredicateContext) GetRight() IPredicateContext { return s.right }

func (s *BinaryComparisonPredicateContext) SetLeft(v IPredicateContext) { s.left = v }

func (s *BinaryComparisonPredicateContext) SetRight(v IPredicateContext) { s.right = v }

func (s *BinaryComparisonPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryComparisonPredicateContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *BinaryComparisonPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *BinaryComparisonPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BinaryComparisonPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBinaryComparisonPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type InPredicateContext struct {
	*PredicateContext
}

func NewInPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InPredicateContext {
	var p = new(InPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *InPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *InPredicateContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *InPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *InPredicateContext) Expressions() IExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *InPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *InPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *InPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitInPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Predicate() (localctx IPredicateContext) {
	return p.predicate(0)
}

func (p *MySqlParser) predicate(_p int) (localctx IPredicateContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPredicateContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 70
	p.EnterRecursionRule(localctx, 70, MySqlParserRULE_predicate, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewExpressionAtomPredicateContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	p.SetState(363)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(361)
			p.Match(MySqlParserLOCAL_ID)
		}
		{
			p.SetState(362)
			p.Match(MySqlParserVAR_ASSIGN)
		}

	}
	{
		p.SetState(365)
		p.ExpressionAtom()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(382)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(380)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBinaryComparisonPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				localctx.(*BinaryComparisonPredicateContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(367)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(368)
					p.ComparisonOperator()
				}
				{
					p.SetState(369)

					var _x = p.predicate(3)

					localctx.(*BinaryComparisonPredicateContext).right = _x
				}

			case 2:
				localctx = NewInPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(371)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				p.SetState(373)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserNOT {
					{
						p.SetState(372)
						p.Match(MySqlParserNOT)
					}

				}
				{
					p.SetState(375)
					p.Match(MySqlParserIN)
				}
				{
					p.SetState(376)
					p.Match(MySqlParserLR_BRACKET)
				}
				{
					p.SetState(377)
					p.Expressions()
				}
				{
					p.SetState(378)
					p.Match(MySqlParserRR_BRACKET)
				}

			}

		}
		p.SetState(384)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext())
	}

	return localctx
}

// IExpressionAtomContext is an interface to support dynamic dispatch.
type IExpressionAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionAtomContext differentiates from other interfaces.
	IsExpressionAtomContext()
}

type ExpressionAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionAtomContext() *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionAtom
	return p
}

func (*ExpressionAtomContext) IsExpressionAtomContext() {}

func NewExpressionAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressionAtom

	return p
}

func (s *ExpressionAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionAtomContext) CopyFrom(ctx *ExpressionAtomContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnaryExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewUnaryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryExpressionAtomContext {
	var p = new(UnaryExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *UnaryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionAtomContext) UnaryOperator() IUnaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOperatorContext)
}

func (s *UnaryExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *UnaryExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnaryExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConstantExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewConstantExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstantExpressionAtomContext {
	var p = new(ConstantExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *ConstantExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantExpressionAtomContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConstantExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewArrayExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayExpressionAtomContext {
	var p = new(ArrayExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *ArrayExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayExpressionAtomContext) Array() IArrayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayContext)
}

func (s *ArrayExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitArrayExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type FullColumnNameExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewFullColumnNameExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FullColumnNameExpressionAtomContext {
	var p = new(FullColumnNameExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *FullColumnNameExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameExpressionAtomContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FullColumnNameExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullColumnNameExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type NestedExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewNestedExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NestedExpressionAtomContext {
	var p = new(NestedExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *NestedExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NestedExpressionAtomContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NestedExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *NestedExpressionAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *NestedExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNestedExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ExpressionAtom() (localctx IExpressionAtomContext) {
	this := p
	_ = this

	localctx = NewExpressionAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, MySqlParserRULE_expressionAtom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) {
	case 1:
		localctx = NewConstantExpressionAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(385)
			p.Constant()
		}

	case 2:
		localctx = NewFullColumnNameExpressionAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(386)
			p.FullColumnName()
		}

	case 3:
		localctx = NewUnaryExpressionAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(387)
			p.UnaryOperator()
		}
		{
			p.SetState(388)
			p.ExpressionAtom()
		}

	case 4:
		localctx = NewNestedExpressionAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(390)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(391)
			p.expression(0)
		}
		p.SetState(396)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(392)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(393)
				p.expression(0)
			}

			p.SetState(398)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(399)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 5:
		localctx = NewArrayExpressionAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(401)
			p.Array()
		}

	}

	return localctx
}

// IArrayContext is an interface to support dynamic dispatch.
type IArrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayContext differentiates from other interfaces.
	IsArrayContext()
}

type ArrayContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayContext() *ArrayContext {
	var p = new(ArrayContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_array
	return p
}

func (*ArrayContext) IsArrayContext() {}

func NewArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayContext {
	var p = new(ArrayContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_array

	return p
}

func (s *ArrayContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayContext) LR_BRACKETS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKETS, 0)
}

func (s *ArrayContext) RR_BRACKETS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKETS, 0)
}

func (s *ArrayContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ArrayContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitArray(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Array() (localctx IArrayContext) {
	this := p
	_ = this

	localctx = NewArrayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, MySqlParserRULE_array)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(404)
		p.Match(MySqlParserLR_BRACKETS)
	}
	p.SetState(413)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(405)
			p.expression(0)
		}
		p.SetState(410)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(406)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(407)
				p.expression(0)
			}

			p.SetState(412)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(415)
		p.Match(MySqlParserRR_BRACKETS)
	}

	return localctx
}

// IUnaryOperatorContext is an interface to support dynamic dispatch.
type IUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryOperatorContext differentiates from other interfaces.
	IsUnaryOperatorContext()
}

type UnaryOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryOperatorContext() *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_unaryOperator
	return p
}

func (*UnaryOperatorContext) IsUnaryOperatorContext() {}

func NewUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unaryOperator

	return p
}

func (s *UnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *UnaryOperatorContext) BIT_NOT_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_NOT_OP, 0)
}

func (s *UnaryOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUS, 0)
}

func (s *UnaryOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *UnaryOperatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *UnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnaryOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UnaryOperator() (localctx IUnaryOperatorContext) {
	this := p
	_ = this

	localctx = NewUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, MySqlParserRULE_unaryOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(417)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserNOT || (int64((_la-1116)) & ^0x3f) == 0 && ((int64(1)<<(_la-1116))&387) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GREATER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATER_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	this := p
	_ = this

	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, MySqlParserRULE_comparisonOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(430)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(419)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(420)
			p.Match(MySqlParserGREATER_SYMBOL)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(421)
			p.Match(MySqlParserLESS_SYMBOL)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(422)
			p.Match(MySqlParserLESS_SYMBOL)
		}
		{
			p.SetState(423)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(424)
			p.Match(MySqlParserGREATER_SYMBOL)
		}
		{
			p.SetState(425)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(426)
			p.Match(MySqlParserLESS_SYMBOL)
		}
		{
			p.SetState(427)
			p.Match(MySqlParserGREATER_SYMBOL)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(428)
			p.Match(MySqlParserEXCLAMATION_SYMBOL)
		}
		{
			p.SetState(429)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	}

	return localctx
}

// ILogicalOperatorContext is an interface to support dynamic dispatch.
type ILogicalOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogicalOperatorContext differentiates from other interfaces.
	IsLogicalOperatorContext()
}

type LogicalOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalOperatorContext() *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_logicalOperator
	return p
}

func (*LogicalOperatorContext) IsLogicalOperatorContext() {}

func NewLogicalOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_logicalOperator

	return p
}

func (s *LogicalOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *LogicalOperatorContext) AllBIT_AND_OP() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBIT_AND_OP)
}

func (s *LogicalOperatorContext) BIT_AND_OP(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_AND_OP, i)
}

func (s *LogicalOperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(MySqlParserOR, 0)
}

func (s *LogicalOperatorContext) AllBIT_OR_OP() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBIT_OR_OP)
}

func (s *LogicalOperatorContext) BIT_OR_OP(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_OR_OP, i)
}

func (s *LogicalOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLogicalOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LogicalOperator() (localctx ILogicalOperatorContext) {
	this := p
	_ = this

	localctx = NewLogicalOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, MySqlParserRULE_logicalOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(438)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserAND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(432)
			p.Match(MySqlParserAND)
		}

	case MySqlParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(433)
			p.Match(MySqlParserBIT_AND_OP)
		}
		{
			p.SetState(434)
			p.Match(MySqlParserBIT_AND_OP)
		}

	case MySqlParserOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(435)
			p.Match(MySqlParserOR)
		}

	case MySqlParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(436)
			p.Match(MySqlParserBIT_OR_OP)
		}
		{
			p.SetState(437)
			p.Match(MySqlParserBIT_OR_OP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

func (p *MySqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 34:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 35:
		var t *PredicateContext = nil
		if localctx != nil {
			t = localctx.(*PredicateContext)
		}
		return p.Predicate_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *MySqlParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySqlParser) Predicate_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
