//go:build ignore
// +build ignore

package main

import (
	"fmt"
	"os"
	"text/template"
	"time"
)

//go:generate go run gen.go

var methodTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT
// This file is generated by go generate at {{ .Timestamp }}

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package grpcdatacoord

import (
	"context"
	"errors"
	"strings"
	"time"

	"github.com/milvus-io/milvus-proto/go-api/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/milvuspb"
	"github.com/milvus-io/milvus/internal/proto/datapb"
	"github.com/milvus-io/milvus/internal/proto/internalpb"
	"github.com/milvus-io/milvus/internal/util/errorutil"
	"github.com/milvus-io/milvus/internal/util/retry"
)
{{ range .Methods }}{{with .}}
// {{.MethodComment}}
func (s *Server) {{.MethodName}}(ctx context.Context, request {{.RequestType}}) ({{.ResponseType}}, error) {
	var resp {{.ResponseType}}
	var err error
	retry.Do(ctx, func() error {
		{{- if .SkipRequestParam}}
		resp, err = s.dataCoord.{{.MethodName}}(ctx)
		{{- else}}
		resp, err = s.dataCoord.{{.MethodName}}(ctx, request)
		{{- end}}
		{{- if eq .ResponseType "*commonpb.Status"}}
		if err == nil &&
			resp.GetErrorCode() == commonpb.ErrorCode_UnexpectedError &&
			strings.Contains(strings.ToLower(resp.GetReason()), errorutil.StandbyStateReason) {
		{{- else}}
		if err == nil &&
			resp.GetStatus().GetErrorCode() == commonpb.ErrorCode_UnexpectedError &&
			strings.Contains(strings.ToLower(resp.GetStatus().GetReason()), errorutil.StandbyStateReason) {
		{{- end}}
			return errors.New("dataCoord is switching from standby to active mode, retry request")
		} else {
			return nil
		}
	}, retry.Attempts(600), retry.Sleep(time.Millisecond*500), retry.MaxSleepTime(5*time.Second))
	return resp, err
}
{{end}}{{end}}`))

type methodDef struct {
	MethodName       string
	RequestType      string
	ResponseType     string
	MethodComment    string
	SkipRequestParam bool
}

func main() {
	f, err := os.OpenFile("service_impl.go", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
	defer f.Close()

	settings := struct {
		Timestamp time.Time
		Methods   []methodDef
	}{
		Timestamp: time.Now(),
		Methods: []methodDef{
			{
				"GetSegmentInfo", "*datapb.GetSegmentInfoRequest", "*datapb.GetSegmentInfoResponse", "GetSegmentInfo gets segment information according to segment id", false,
			},
			{
				"Flush", "*datapb.FlushRequest", "*datapb.FlushResponse", "Flush flushes a collection's data", false,
			},
			{
				"AssignSegmentID", "*datapb.AssignSegmentIDRequest", "*datapb.AssignSegmentIDResponse", "AssignSegmentID requests to allocate segment space for insert", false,
			},
			{
				"GetSegmentStates", "*datapb.GetSegmentStatesRequest", "*datapb.GetSegmentStatesResponse", "GetSegmentStates gets states of segments", false,
			},
			{
				"GetInsertBinlogPaths", "*datapb.GetInsertBinlogPathsRequest", "*datapb.GetInsertBinlogPathsResponse", "GetInsertBinlogPaths gets insert binlog paths of a segment", false,
			},
			{
				"GetCollectionStatistics", "*datapb.GetCollectionStatisticsRequest", "*datapb.GetCollectionStatisticsResponse", "GetCollectionStatistics gets statistics of a collection", false,
			},
			{
				"GetPartitionStatistics", "*datapb.GetPartitionStatisticsRequest", "*datapb.GetPartitionStatisticsResponse", "GetPartitionStatistics gets statistics of a partition", false,
			},
			{
				"GetSegmentInfoChannel", "*datapb.GetSegmentInfoChannelRequest", "*milvuspb.StringResponse", "GetSegmentInfoChannel gets channel to which datacoord sends segment information", true,
			},
			{
				"SaveBinlogPaths", "*datapb.SaveBinlogPathsRequest", "*commonpb.Status", "SaveBinlogPaths implement DataCoordServer, saves segment, collection binlog according to datanode request", false,
			},
			{
				"GetRecoveryInfo", "*datapb.GetRecoveryInfoRequest", "*datapb.GetRecoveryInfoResponse", "GetRecoveryInfo gets information for recovering channels", false,
			},
			{
				"GetFlushedSegments", "*datapb.GetFlushedSegmentsRequest", "*datapb.GetFlushedSegmentsResponse", "GetFlushedSegments get all flushed segments of a partition", false,
			},
			{
				"GetSegmentsByStates", "*datapb.GetSegmentsByStatesRequest", "*datapb.GetSegmentsByStatesResponse", "GetSegmentsByStates get all segments of a partition by given states", false,
			},
			{
				"ShowConfigurations", "*internalpb.ShowConfigurationsRequest", "*internalpb.ShowConfigurationsResponse", "ShowConfigurations gets specified configurations para of DataCoord", false,
			},
			{
				"GetMetrics", "*milvuspb.GetMetricsRequest", "*milvuspb.GetMetricsResponse", "GetMetrics gets metrics of data coordinator and datanodes", false,
			},
			{
				"ManualCompaction", "*milvuspb.ManualCompactionRequest", "*milvuspb.ManualCompactionResponse", "ManualCompaction triggers a compaction for a collection", false,
			},
			{
				"GetCompactionState", "*milvuspb.GetCompactionStateRequest", "*milvuspb.GetCompactionStateResponse", "GetCompactionState gets the state of a compaction", false,
			},
			{
				"GetCompactionStateWithPlans", "*milvuspb.GetCompactionPlansRequest", "*milvuspb.GetCompactionPlansResponse", "GetCompactionStateWithPlans gets the state of a compaction by plan", false,
			},
			{
				"WatchChannels", "*datapb.WatchChannelsRequest", "*datapb.WatchChannelsResponse", "WatchChannels starts watch channels by give request", false,
			},
			{
				"GetFlushState", "*milvuspb.GetFlushStateRequest", "*milvuspb.GetFlushStateResponse", "GetFlushState gets the flush state of multiple segments", false,
			},
			{
				"DropVirtualChannel", "*datapb.DropVirtualChannelRequest", "*datapb.DropVirtualChannelResponse", "DropVirtualChannel drop virtual channel in datacoord", false,
			},
			{
				"SetSegmentState", "*datapb.SetSegmentStateRequest", "*datapb.SetSegmentStateResponse", "SetSegmentState sets the state of a segment", false,
			},
			{
				"Import", "*datapb.ImportTaskRequest", "*datapb.ImportTaskResponse", "Import data files(json, numpy, etc.) on MinIO/S3 storage, read and parse them into sealed segments", false,
			},
			{
				"UpdateSegmentStatistics", "*datapb.UpdateSegmentStatisticsRequest", "*commonpb.Status", "UpdateSegmentStatistics is the dataCoord service caller of UpdateSegmentStatistics", false,
			},
			{
				"UpdateChannelCheckpoint", "*datapb.UpdateChannelCheckpointRequest", "*commonpb.Status", "UpdateChannelCheckpoint updates channel checkpoint in dataCoord", false,
			},
			{
				"AcquireSegmentLock", "*datapb.AcquireSegmentLockRequest", "*commonpb.Status", "AcquireSegmentLock acquire the reference lock of the segments", false,
			},
			{
				"ReleaseSegmentLock", "*datapb.ReleaseSegmentLockRequest", "*commonpb.Status", "ReleaseSegmentLock release the reference lock of the segments", false,
			},
			{
				"SaveImportSegment", "*datapb.SaveImportSegmentRequest", "*commonpb.Status", "SaveImportSegment saves the import segment binlog paths data and then looks for the right DataNode to add the\n// segment to that DataNode", false,
			},
			{
				"UnsetIsImportingState", "*datapb.UnsetIsImportingStateRequest", "*commonpb.Status", "UnsetIsImportingState is the distributed caller of UnsetIsImportingState", false,
			},
			{
				"MarkSegmentsDropped", "*datapb.MarkSegmentsDroppedRequest", "*commonpb.Status", "MarkSegmentsDropped is the distributed caller of MarkSegmentsDropped", false,
			},
			{
				"BroadcastAlteredCollection", "*datapb.AlterCollectionRequest", "*commonpb.Status", "BroadcastAlteredCollection", false,
			},
			{
				"GcConfirm", "*datapb.GcConfirmRequest", "*datapb.GcConfirmResponse", "GcConfirm", false,
			},
		},
	}
	methodTemplate.Execute(f, settings)
}
